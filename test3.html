<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=1200, initial-scale=device-width/1200">
    <title>Cashback Payout + Trading Simulation</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Chart.js CDN for graphing (removed, but keeping for reference if needed later) -->
    <!-- <script src="https://cdn.jsdelivr.net/npm/chart.js"></script> -->
    <!-- Inter Font -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4ff;
            color: #333;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 2rem;
        }
        .container {
            background-color: #ffffff;
            border-radius: 1.5rem;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            padding: 2.5rem;
            max-width: 1200px;
            width: 100%;
            margin-top: 2rem;
        }
        h1 {
            font-size: 2.5rem;
            font-weight: 800;
            color: #1a202c;
            text-align: center;
            margin-bottom: 2rem;
        }
        .input-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }
        .input-field {
            display: flex;
            flex-direction: column;
        }
        label {
            display: block;
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: #4a5568;
        }
        input[type="number"], input[type="date"], select {
            width: 100%;
            padding: 0.75rem 1rem;
            border: 1px solid #e2e8f0;
            border-radius: 0.5rem;
            font-size: 1rem;
            color: #333;
            transition: border-color 0.2s, box-shadow 0.2s;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%236B7280%22%20d%3D%22M287%2C197.3L159.2%2C69.5c-3.2-3.2-8.4-3.2-11.6%2C0L5.4%2C197.3c-3.2%2C3.2-3.2%2C8.4%2C0%2C11.6l11.6%2C11.6c3.2%2C3.2%2C8.4%2C3.2%2C11.6%2C0l124.6-124.6l124.6%2C124.6c3.2%2C3.2%2C8.4%2C3.2%2C11.6%2C0l11.6-11.6C290.2%2C205.7%2C290.2%2C200.5%2C287%2C197.3z%22%2F%3E%3C%2Fsvg%3E');
            background-repeat: no-repeat;
            background-position: right 0.75rem center;
            background-size: 0.8rem auto;
        }
        input[type="date"] {
            background-image: none;
        }
        input[type="number"]::-webkit-outer-spin-button,
        input[type="number"]::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        input[type="number"] {
            -moz-appearance: textfield;
        }
        input[type="number"]:focus, input[type="date"]:focus, select:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.25);
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 2rem;
        }
        th, td {
            padding: 0.75rem 1rem;
            border: 1px solid #e2e8f0;
            text-align: left;
            font-size: 0.875rem; /* Default font size for table cells */
        }
        th {
            background-color: #e0f2fe;
            color: #2c5282;
            font-weight: 700;
            text-transform: uppercase;
            font-size: 0.875rem;
        }
        tbody tr:nth-child(odd) {
            background-color: #f8fafc;
        }
        tbody tr:hover {
            background-color: #eef7ff;
        }
        .summary {
            margin-top: 2rem;
            padding: 1.5rem;
            background-color: #e0f2fe;
            border-radius: 0.75rem;
            text-align: center;
            font-size: 1.25rem;
            font-weight: 600;
            color: #2c5282;
        }
        .summary span {
            color: #007bff;
            font-weight: 700;
        }
        .text-green-600 {
            color: #22c55e;
        }
        .text-red-600 {
            color: #ef4444;
        }
        .text-orange-600 {
            color: #f97316;
        }
        .stress-test-checkbox {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-top: 1rem;
        }
        .stress-test-checkbox input[type="checkbox"] {
            width: auto;
            margin: 0;
        }
        /* Removed chart-container styles */
        .table-container {
            margin-top: 2rem; /* Keep margin for table container */
            background-color: #ffffff;
            border-radius: 1.5rem;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            padding: 1.5rem;
        }
        .table-container h2 {
            font-size: 1.5rem;
            font-weight: 700;
            color: #1a202c;
            text-align: center;
            margin-bottom: 1.5rem;
        }


        /* Daily Log Specific Styles */
        .daily-log-section {
            margin-top: 3rem;
            padding-top: 2rem;
            border-top: 1px solid #e2e8f0;
        }
        .daily-log-section h2 {
            font-size: 2rem;
            font-weight: 800;
            color: #1a202c;
            text-align: center;
            margin-bottom: 1.5rem;
        }
        .daily-log-controls {
            display: flex;
            justify-content: center;
            margin-bottom: 1.5rem;
        }
        .daily-log-controls select {
            width: auto;
            min-width: 250px;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            body {
                padding: 1rem;
            }
            .container {
                padding: 1.5rem;
            }
            h1 {
                font-size: 2rem;
            }
            .input-grid {
                grid-template-columns: 1fr;
            }
            th, td {
                padding: 0.5rem 0.75rem;
                font-size: 0.75rem; /* Smaller font size on mobile */
            }
            .summary {
                font-size: 1rem;
                padding: 1rem;
            }
            .daily-log-section h2 {
                font-size: 1.5rem;
            }
            .daily-log-controls {
                flex-direction: column;
                align-items: center;
            }
            .daily-log-controls select {
                width: 100%;
                margin-bottom: 1rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Cashback Payout + Trading Simulation</h1>
        <p class="text-center text-gray-600 mb-6">Model the growth of a trading fund and its ability to cover delayed cashback payouts.</p>

        <div class="input-grid">
            <div class="input-field">
                <label for="membershipTier">Membership Tier:</label>
                <select id="membershipTier">
                    <option value="Free">Free</option>
                    <option value="Standard">Standard</option>
                    <option value="Premium" selected>Premium</option>
                </select>
            </div>
            <div class="input-field">
                <label for="simulationStartDate">Simulation Start Date:</label>
                <input type="date" id="simulationStartDate">
            </div>
            <div class="input-field">
                <label for="voucherValue">Voucher Value (J$):</label>
                <select id="voucherValue">
                    <option value="10000">10,000</option>
                    <option value="15000">15,000</option>
                    <option value="20000" selected>20,000</option>
                </select>
            </div>
            <div class="input-field">
                <label for="vouchersPerMonth">Vouchers per Month:</label>
                <select id="vouchersPerMonth">
                    <option value="1">1</option>
                    <option value="2">2</option>
                    <option value="3" selected>3</option>
                </select>
            </div>
            <div class="input-field">
                <label for="markupRate">Markup Rate (%):</label>
                <input type="number" id="markupRate" value="25" min="0" max="100" step="1">
            </div>
            <div class="input-field">
                <label for="markupAllocationToTradingFund">Markup Allocation to Fund (%):</label>
                <input type="number" id="markupAllocationToTradingFund" value="17" min="0" max="100" step="1">
            </div>
            <div class="input-field">
                <label for="initialTradingFund">Initial Trading Fund (J$):</label>
                <input type="number" id="initialTradingFund" value="0" min="0" step="100" title="This is the fund balance at the very start of the simulation, before any monthly contributions are added.">
            </div>
            <div class="input-field">
                <label for="avgWeeklyWin">Avg Weekly Win (%):</label>
                <input type="number" id="avgWeeklyWin" value="10.68" min="0" max="100" step="0.01">
            </div>
            <div class="input-field">
                <label for="maxWeeklyLoss">Max Weekly Loss (%):</label>
                <input type="number" id="maxWeeklyLoss" value="5" min="0" max="100" step="1">
            </div>
            <div class="input-field">
                <label for="winRate">Win Rate (%):</label>
                <input type="number" id="winRate" value="53.4" min="0" max="100" step="0.1">
            </div>
            <div class="input-field">
                <label for="simulationSeed">Simulation Seed (Optional):</label>
                <input type="number" id="simulationSeed" value="1" placeholder="Enter a number for consistent results">
            </div>
            <div class="input-field stress-test-checkbox">
                <input type="checkbox" id="stressTestMode">
                <label for="stressTestMode" class="mb-0">Enable Stress Test Mode</label>
            </div>
        </div>

        <div class="overflow-x-auto">
            <table id="simulationTable" class="min-w-full divide-y divide-gray-200">
                <thead>
                    <tr>
                        <th class="px-6 py-3">Month</th>
                        <th class="px-6 py-3">Purchase Date</th>
                        <th class="px-6 py-3">Monthly Fund Contribution (J$)</th>
                    </tr>
                </thead>
                <tbody>
                    <!-- Simulation rows will be generated here -->
                </tbody>
            </table>
        </div>

        <div class="summary">
            <h2 class="text-xl font-bold mb-4">12-Month Rolling View Summary</h2>
            <p>Cumulative Voucher Purchases: <span id="cumulativeVoucherPurchases" class="font-bold">J$0</span></p>
            <p>Total Cashback Owed (Accrued): <span id="totalCashbackOwedAccrued" class="font-bold">J$0</span></p>
            <p>Total Cashback Paid: <span id="totalCashbackPaid" class="font-bold">J$0</span></p>
            <p>Net Fund Performance: <span id="netFundPerformance" class="font-bold">J$0</span></p>
            <p>Overall Payout Status: <span id="overallPayoutStatus" class="font-bold"></span></p>
        </div>

        <!-- Removed chart wrapper div -->

        <!-- Combined Table for Net Payout Obligation and Fund Balance After Payout -->
        <div class="table-container">
            <h2>Payout Obligation & Fund Performance</h2>
            <div class="overflow-x-auto">
                <table id="combinedPayoutTable" class="min-w-full divide-y divide-gray-200">
                    <thead>
                        <tr>
                            <th class="px-6 py-3">Month</th>
                            <th class="px-6 py-3">Cashback Due Date</th>
                            <th class="px-6 py-3">Payout Month-End</th>
                            <th class="px-6 py-3">Net Payout Obligation (J$)</th>
                            <th class="px-6 py-3">Payout Deducted (J$)</th> <!-- New column here -->
                            <th class="px-6 py-3">Fund Balance After Payout (J$)</th>
                            <th class="px-6 py-3">Payout Met?</th>
                        </tr>
                    </thead>
                    <tbody>
                        <!-- Combined Payout rows will be generated here -->
                    </tbody>
                </table>
            </div>
        </div>


        <!-- Daily Trading Log Section -->
        <div class="daily-log-section">
            <h2>Cumulative Daily Trading Log</h2>
            <div class="overflow-x-auto">
                <table id="dailyLogTable" class="min-w-full divide-y divide-gray-200">
                    <thead>
                        <tr>
                            <th class="px-6 py-3">Day</th>
                            <th class="px-6 py-3">Date</th>
                            <th class="px-6 py-3">Day of Week</th>
                            <th class="px-6 py-3">Trading Day?</th>
                            <th class="px-6 py-3">Event Occurred?</th>
                            <th class="px-6 py-3">Event Type</th>
                            <th class="px-6 py-3">Net Change (J$)</th>
                            <th class="px-6 py-3">Capital Before Event (J$)</th>
                            <th class="px-6 py-3">Capital After Event (J$)</th>
                        </tr>
                    </thead>
                <tbody>
                    <!-- Daily log rows will be generated here -->
                </tbody>
            </table>
        </div>
    </div>

    </div>

    <script>
        // --- Constants and Configuration ---
        const PAYOUT_DELAY_DAYS = 121;
        const TRADING_WEEKS_PER_MONTH = 8; // Used for monthly simulation (approx 2 trades per week)
        const TOTAL_TRADES_FOR_CUMULATIVE_LOG = 8 * 12; // Roughly 8 trades per month for 12 months, adjust as needed for daily granularity
        // Calculate the number of extra months needed for payouts to complete
        // Add an extra month to ensure all 12 months of payouts are covered, even for purchases late in the month.
        const EXTRA_MONTHS_FOR_PAYOUTS = Math.ceil(PAYOUT_DELAY_DAYS / 30.4375) + 1; // Approx 4 + 1 = 5 months
        const TOTAL_SIMULATION_MONTHS = 12 + EXTRA_MONTHS_FOR_PAYOUTS; // Total months to run the internal simulation (12 + 5 = 17)

        const MEMBERSHIP_TIERS = {
            'Free': {
                fee: 0,
                cashbackRates: { 10000: 0.30, 15000: 0.30, 20000: 0.30 }
            },
            'Standard': {
                fee: 4200,
                cashbackRates: { 10000: 0.33, 15000: 0.34, 20000: 0.36 }
            },
            'Premium': {
                fee: 8400,
                cashbackRates: { 10000: 0.37, 15000: 0.41, 20000: 0.49 }
            }
        };

        // --- DOM Elements ---
        const membershipTierInput = document.getElementById('membershipTier');
        const simulationStartDateInput = document.getElementById('simulationStartDate');
        const voucherValueInput = document.getElementById('voucherValue');
        const vouchersPerMonthInput = document.getElementById('vouchersPerMonth');
        const markupRateInput = document.getElementById('markupRate');
        const markupAllocationToTradingFundInput = document.getElementById('markupAllocationToTradingFund');
        const initialTradingFundInput = document.getElementById('initialTradingFund');
        const avgWeeklyWinInput = document.getElementById('avgWeeklyWin');
        const maxWeeklyLossInput = document.getElementById('maxWeeklyLoss');
        const winRateInput = document.getElementById('winRate');
        const simulationSeedInput = document.getElementById('simulationSeed'); // New seed input
        const stressTestModeCheckbox = document.getElementById('stressTestMode');

        const simulationTableBody = document.querySelector('#simulationTable tbody');
        const cumulativeVoucherPurchasesSpan = document.getElementById('cumulativeVoucherPurchases');
        const totalCashbackOwedAccruedSpan = document.getElementById('totalCashbackOwedAccrued');
        const totalCashbackPaidSpan = document.getElementById('totalCashbackPaid');
        const netFundPerformanceSpan = document.getElementById('netFundPerformance');
        const overallPayoutStatusSpan = document.getElementById('overallPayoutStatus');
        // Removed chart canvas elements
        // const chartCanvas = document.getElementById('simulationChart');
        // const netPayoutObligationChartCanvas = document.getElementById('netPayoutObligationChart');
        // const surplusDeficitChartCanvas = document.getElementById('surplusDeficitChart');

        // Removed chart instances
        // let simulationChart;
        // let netPayoutObligationChartInstance;
        // let surplusDeficitChartInstance;

        // New table bodies
        const combinedPayoutTableBody = document.querySelector('#combinedPayoutTable tbody');


        // Daily Log DOM Elements
        const dailyLogTableBody = document.querySelector('#dailyLogTable tbody'); // Removed selector dropdown

        let monthlySimulationResults = []; // Store results for daily log selection (includes extended months)
        let monthlyPurchaseData = []; // Store only the first 12 months of purchase data for display

        // --- Seeded Random Number Generator ---
        // Simple Linear Congruential Generator (LCG)
        class SeededRandom {
            constructor(seed) {
                this.seed = seed % 2147483647; // Modulo to keep it within a reasonable range for LCG
                if (this.seed <= 0) this.seed += 2147483646; // Ensure positive seed
            }

            next() {
                this.seed = (this.seed * 16807) % 2147483647;
                return (this.seed - 1) / 2147483646; // Return a value between 0 (inclusive) and 1 (exclusive)
            }
        }

        let rng = null; // Global instance of the seeded random generator

        // --- Helper Functions ---

        /**
         * Formats a number as Jamaican Dollar currency.
         * @param {number} amount - The amount to format.
         * @returns {string} The formatted currency string.
         */
        const formatCurrency = (amount) => {
            return new Intl.NumberFormat('en-JM', {
                style: 'currency',
                currency: 'JMD',
                minimumFractionDigits: 0,
                maximumFractionDigits: 0
            }).format(amount);
        };

        /**
         * Adds a specified number of days to a Date object, maintaining Jamaica timezone alignment.
         * @param {Date} date - The starting Date object (expected to be Jamaica-aligned).
         * @param {number} days - The number of days to add.
         * @returns {Date} A new Date object with the added days, also Jamaica-aligned.
         */
        const addDays = (date, days) => {
            const result = new Date(date);
            result.setDate(result.getDate() + days);
            return result;
        };

        /**
         * Gets the last day of the month for a given date, aligned to America/Jamaica timezone.
         * @param {Date} date - The Date object (expected to be Jamaica-aligned).
         * @returns {Date} A new Date object representing the last day of the month in America/Jamaica.
         */
        const getEndOfMonthJamaica = (date) => {
            // Get year and month components as they would be in Jamaica
            const jamaicaDate = new Date(date.toLocaleString('en-US', { timeZone: 'America/Jamaica' }));
            const year = jamaicaDate.getFullYear();
            const month = jamaicaDate.getMonth(); // 0-indexed

            // Create a date for the first day of the *next* month in Jamaica time
            // By setting UTC hours to 5, we ensure it's midnight Jamaica time (UTC-5)
            const firstDayOfNextMonthJamaica = new Date(Date.UTC(year, month + 1, 1, 5, 0, 0));

            // Subtract one day to get the last day of the current month in Jamaica time
            firstDayOfNextMonthJamaica.setDate(firstDayOfNextMonthJamaica.getDate() - 1);

            return firstDayOfNextMonthJamaica;
        };


        /**
         * Generates a shuffled array of win/loss outcomes for a given number of trades.
         * Ensures the exact win rate is met.
         * @param {number} totalTrades - Total number of trades.
         * @param {number} winRatePercent - Win rate as a percentage (e.g., 60).
         * @param {SeededRandom} rngInstance - The seeded random number generator instance.
         * @returns {boolean[]} An array where true is a win, false is a loss.
         */
        const generateTradeOutcomes = (totalTrades, winRatePercent, rngInstance) => {
            const numWins = Math.round(totalTrades * (winRatePercent / 100));
            const numLosses = totalTrades - numWins;

            const outcomes = [];
            for (let i = 0; i < numWins; i++) {
                outcomes.push(true); // Win
            }
            for (let i = 0; i < numLosses; i++) {
                outcomes.push(false); // Loss
            }

            // Shuffle the array (Fisher-Yates algorithm) using the seeded RNG
            for (let i = outcomes.length - 1; i > 0; i--) {
                const j = Math.floor(rngInstance.next() * (i + 1)); // Use rngInstance.next()
                [outcomes[i], outcomes[j]] = [outcomes[j], outcomes[i]];
            }
            return outcomes;
        };

        // --- Main Simulation Logic (Monthly) ---

        const runSimulation = () => {
            // 1. Read Input Parameters
            const selectedTier = membershipTierInput.value;
            const simulationStartDateString = simulationStartDateInput.value;
            const voucherValue = parseInt(voucherValueInput.value);
            const vouchersPerMonth = parseInt(vouchersPerMonthInput.value); // Now reads from select
            const markupRate = parseFloat(markupRateInput.value) / 100; // Convert to decimal
            const markupAllocationToTradingFund = parseFloat(markupAllocationToTradingFundInput.value) / 100; // Convert to decimal
            let avgWeeklyWin = parseFloat(avgWeeklyWinInput.value) / 100; // Convert to decimal
            let maxWeeklyLoss = parseFloat(maxWeeklyLossInput.value) / 100; // Convert to decimal
            let winRate = parseFloat(winRateInput.value); // Percentage

            const isStressTestMode = stressTestModeCheckbox.checked;

            if (isStressTestMode) {
                // Apply stress test adjustments
                avgWeeklyWin *= 0.8; // Reduce average win by 20%
                maxWeeklyLoss *= 1.2; // Increase max loss by 20%
                winRate = Math.max(0, winRate - 10); // Reduce win rate by 10 percentage points, not below 0
            }

            const tierConfig = MEMBERSHIP_TIERS[selectedTier];
            const membershipFee = tierConfig.fee;
            const cashbackRate = tierConfig.cashbackRates[voucherValue];

            const monthlyVoucherSpend = voucherValue * vouchersPerMonth;
            const markupPerMonth = monthlyVoucherSpend * markupRate;
            const monthlyTradingFundContribution = markupPerMonth * markupAllocationToTradingFund;

            const membershipAllocationToTradingFund = 0.50; // 50%
            const oneTimeMembershipFundAddition = membershipFee * membershipAllocationToTradingFund;

            // Calculate the base initial fund for Month 1's contribution
            const calculatedMonth1BaseContribution = monthlyTradingFundContribution + oneTimeMembershipFundAddition;

            // currentTradingFundAtStartOfMonth represents the fund balance at the very beginning of each month,
            // before that month's new contributions are added.
            let currentTradingFundAtStartOfMonth = parseFloat(initialTradingFundInput.value);

            // Initialize Seeded Random Number Generator
            const seedValue = parseInt(simulationSeedInput.value);
            rng = new SeededRandom(isNaN(seedValue) || simulationSeedInput.value === '' ? Date.now() : seedValue);


            // Parse Start Date to be consistently in America/Jamaica timezone
            let initialDate;
            if (simulationStartDateString) {
                const [year, month, day] = simulationStartDateString.split('-').map(Number);
                // Create a Date object whose internal UTC time corresponds to midnight in Jamaica (UTC-5)
                // So, 00:00 Jamaica time is 05:00 UTC.
                initialDate = new Date(Date.UTC(year, month - 1, day, 5, 0, 0));
            } else {
                // For default today's date, also ensure it's Jamaica's midnight
                const now = new Date();
                // Get current date components in Jamaica timezone
                const jamaicaTime = new Date(now.toLocaleString('en-US', { timeZone: 'America/Jamaica' }));
                const year = jamaicaTime.getFullYear();
                const month = jamaicaTime.getMonth();
                const day = jamaicaTime.getDate();
                // Create a UTC date corresponding to Jamaica midnight
                initialDate = new Date(Date.UTC(year, month, day, 5, 0, 0));

                // Set default date input value to today's date in Jamaica
                // Use toISOString and slice to get YYYY-MM-DD from a Jamaica-aligned date
                simulationStartDateInput.value = new Date(jamaicaTime.getTime() - (jamaicaTime.getTimezoneOffset() * 60000)).toISOString().split('T')[0];
            }


            // Calculate the portion of cashback covered by the 83% markup allocation
            const markupAllocationToPayoutPercent = 1 - markupAllocationToTradingFund;
            const amountCoveredByMarkup = monthlyVoucherSpend * markupRate * markupAllocationToPayoutPercent;


            // --- Simulation Variables ---
            monthlySimulationResults = []; // Clear and re-initialize for monthly results (will contain all calculated months)
            monthlyPurchaseData = []; // Clear and re-initialize for display (only first 12 months of purchases)
            let cumulativeVoucherPurchases = 0;
            let totalCashbackOwedAccrued = 0; // This will now track the net obligation
            // let totalCashbackPaid = 0; // Will be calculated from daily log deductions - moved after daily sim
            // let overallPayoutSuccess = true; // Assume success until a deficit occurs - moved after daily sim

            // --- Monthly Simulation Loop (Extended to cover all payouts) ---
            for (let monthIndex = 0; monthIndex < TOTAL_SIMULATION_MONTHS; monthIndex++) {
                const monthData = {
                    actualPayoutSurplusDeficit: null, // Explicitly initialize
                    actualPayoutMetStatus: null,      // Explicitly initialize
                    payoutDeductedInThisMonth: 0,     // Initialize new field for explicit deduction (accumulates for this sim month)
                    actualDeductionForThisPurchaseMonth: 0 // Initialize for combinedPayoutTable
                };

                // For the first 12 months, calculate purchase-related data
                if (monthIndex < 12) {
                    // Create purchaseDate aligned to Jamaica timezone
                    const purchaseDate = new Date(Date.UTC(initialDate.getUTCFullYear(), initialDate.getUTCMonth() + monthIndex, initialDate.getUTCDate(), 5, 0, 0));
                    monthData.purchaseDate = purchaseDate;
                    monthData.totalCashbackOwed = monthlyVoucherSpend * cashbackRate; // Full cashback owed for this month's purchases
                    monthData.cashbackAccruedThisMonth = monthData.totalCashbackOwed; // Store for summary
                    monthData.accruedNetPayoutObligation = Math.max(0, monthData.totalCashbackOwed - amountCoveredByMarkup);
                } else {
                    // For extended months, no new purchases, so obligations are zero
                    monthData.purchaseDate = null; // No new purchases
                    monthData.cashbackAccruedThisMonth = 0;
                    monthData.accruedNetPayoutObligation = 0;
                }

                // Calculate Dates relevant to the current month in the loop
                // This is based on the *current month's position* in the simulation, not the purchase date
                const currentMonthDate = new Date(Date.UTC(initialDate.getUTCFullYear(), initialDate.getUTCMonth() + monthIndex, initialDate.getUTCDate(), 5, 0, 0));
                monthData.month = monthIndex + 1; // This is the simulation month number
                // The cashbackDueDate and payoutMonthEnd for the simulation table are based on the *purchase date*
                // These are placeholders for the simulation loop's internal use, actual ones are stored on pastMonthData
                monthData.cashbackDueDate = new Date(); // Placeholder
                monthData.payoutMonthEnd = new Date(); // Placeholder

                // Determine this month's specific contribution to the fund
                let monthlyContributionForCurrentMonth;
                if (monthIndex === 0) {
                    monthlyContributionForCurrentMonth = calculatedMonth1BaseContribution;
                } else if (monthIndex < 12) { // Only contribute for the first 12 months of purchases
                    monthlyContributionForCurrentMonth = monthlyTradingFundContribution;
                } else {
                    monthlyContributionForCurrentMonth = 0; // No new contributions after 12 months
                }
                monthData.monthlyFundContribution = monthlyContributionForCurrentMonth;

                // Starting capital for this month (fund balance from end of previous month)
                monthData.startingTradingCapital = currentTradingFundAtStartOfMonth;

                // Capital available for trading this month (Starting Capital + Monthly Contribution)
                let capitalForTradingThisMonth = currentTradingFundAtStartOfMonth + monthlyContributionForCurrentMonth;

                // Simulate Weekly Trades (20 trades per month) - This part is primarily for monthly overview
                // The detailed daily trade simulation happens in runCumulativeDailySimulation
                const tradeOutcomes = generateTradeOutcomes(TRADING_WEEKS_PER_MONTH, winRate, rng); // Pass rng
                let fundAfterTrades = capitalForTradingThisMonth; // Start trading with this combined capital

                for (let week = 0; week < TRADING_WEEKS_PER_MONTH; week++) {
                    const isWin = tradeOutcomes[week];
                    let gainLossAmount;
                    // Ensure we don't calculate percentage of a negative fund for trading
                    const capitalForTradeCalculation = fundAfterTrades; // Allow trading on negative capital

                    if (isWin) {
                        gainLossAmount = capitalForTradeCalculation * avgWeeklyWin;
                    } else {
                        gainLossAmount = -capitalForTradeCalculation * maxWeeklyLoss;
                    }
                    fundAfterTrades += gainLossAmount;
                }

                // Store the fund's status *before* any potential payout for a past month's purchases
                monthData.endingTradingCapitalBeforePayout = fundAfterTrades;

                // --- Handle Delayed Payouts (Actual Deductions) ---
                // This part of the monthly loop is primarily for accumulating payoutDeductedInThisMonth
                // and setting up the pastMonthData.actualDeductionForThisPurchaseMonth.
                // The actualPayoutSurplusDeficit and actualPayoutMetStatus will be finalized by the daily simulation.
                const currentSimMonthEnd = getEndOfMonthJamaica(currentMonthDate);

                for (let i = 0; i < monthlySimulationResults.length; i++) {
                    const pastMonthData = monthlySimulationResults[i];
                    // Only process if it's a purchase month (i.e., i < 12)
                    // and its payout hasn't been processed yet by this monthly loop (actualPayoutMetStatus === null)
                    if (i < 12 && pastMonthData.purchaseDate && pastMonthData.actualPayoutMetStatus === null) {
                        const payoutDateForPastPurchase = addDays(pastMonthData.purchaseDate, PAYOUT_DELAY_DAYS);
                        const payoutMonthEndDateForPastPurchase = getEndOfMonthJamaica(payoutDateForPastPurchase);

                        if (payoutMonthEndDateForPastPurchase.getTime() <= currentSimMonthEnd.getTime()) {
                            const owedFromPastFull = pastMonthData.cashbackAccruedThisMonth;
                            const netCashbackToCoverByTradingFund = Math.max(0, owedFromPastFull - amountCoveredByMarkup);
                            
                            // This deduction is for the *monthly* overview table's payout deducted column.
                            // The actual fund deduction for the daily log will happen in runCumulativeDailySimulation.
                            const deductionForMonthlyTable = netCashbackToCoverByTradingFund;
                            monthData.payoutDeductedInThisMonth += deductionForMonthlyTable;
                            pastMonthData.actualDeductionForThisPurchaseMonth = deductionForMonthlyTable; // Store for combinedPayoutTable
                        }
                    }
                }

                monthData.endingTradingCapital = fundAfterTrades; // Final ending capital for the month (before daily sim adjustments)
                currentTradingFundAtStartOfMonth = monthData.endingTradingCapital; // This becomes the starting capital for the *next* month's calculation

                monthlySimulationResults.push(monthData); // Add to the full simulation results

                // Only add to monthlyPurchaseData if it's one of the initial 12 purchase months
                if (monthIndex < 12) {
                    const purchaseDateForDisplay = new Date(Date.UTC(initialDate.getUTCFullYear(), initialDate.getUTCMonth() + monthIndex, initialDate.getUTCDate(), 5, 0, 0));
                    monthData.cashbackDueDate = addDays(purchaseDateForDisplay, PAYOUT_DELAY_DAYS);
                    monthData.payoutMonthEnd = getEndOfMonthJamaica(monthData.cashbackDueDate);

                    monthlyPurchaseData.push(monthData);
                    // Update Cumulative Voucher Purchases (still full value)
                    cumulativeVoucherPurchases += monthlyVoucherSpend;
                    // Update Total Cashback Owed (Accrued) with the NET obligation
                    totalCashbackOwedAccrued += monthData.accruedNetPayoutObligation;
                }
            }

            // --- Update UI ---
            // Display only the first 12 months of purchase data in the tables
            updateTable(monthlyPurchaseData);

            // Run cumulative daily simulation and get the final fund performance.
            // This function will also update the actualPayoutSurplusDeficit and actualPayoutMetStatus
            // within the monthlyPurchaseData objects based on daily fund movements.
            const finalNetFundPerformance = runCumulativeDailySimulation();

            // Recalculate overallPayoutSuccess and totalCashbackPaid after daily simulation has updated monthlyPurchaseData
            let totalCashbackPaid = 0;
            let overallPayoutSuccess = true; // Reset and re-evaluate
            monthlyPurchaseData.forEach(data => {
                totalCashbackPaid += data.actualDeductionForThisPurchaseMonth;
                if (data.actualPayoutMetStatus === false) { // If any single payout was a shortfall
                    overallPayoutSuccess = false;
                }
            });

            updateCombinedPayoutTable(monthlyPurchaseData); // Update combined table AFTER daily sim has finalized payout statuses
            updateSummary(cumulativeVoucherPurchases, totalCashbackOwedAccrued, totalCashbackPaid, finalNetFundPerformance, overallPayoutSuccess);
        };

        /**
         * Updates the simulation results table.
         * @param {Array<Object>} results - The array of monthly simulation data (first 12 months of purchases).
         */
        const updateTable = (results) => {
            simulationTableBody.innerHTML = ''; // Clear existing rows

            results.forEach(data => {
                const row = `
                    <tr>
                        <td class="px-6 py-4 whitespace-nowrap">${data.month}</td>
                        <td class="px-6 py-4 whitespace-nowrap">${data.purchaseDate.toLocaleDateString('en-JM', { day: 'numeric', month: 'short', year: 'numeric', timeZone: 'America/Jamaica' })}</td>
                        <td class="px-6 py-4 whitespace-nowrap">${formatCurrency(data.monthlyFundContribution)}</td>
                    </tr>
                `;
                simulationTableBody.insertAdjacentHTML('beforeend', row);
            });
        };

        /**
         * Updates the combined Net Payout Obligation and Fund Balance After Payout table.
         * @param {Array<Object>} results - The array of monthly simulation data (first 12 months of purchases).
         */
        const updateCombinedPayoutTable = (results) => {
            combinedPayoutTableBody.innerHTML = ''; // Clear existing rows

            results.forEach(data => {
                let fundBalanceDisplay;
                let fundBalanceClass;
                let payoutMetDisplay;
                let payoutMetClass;
                let payoutDeductedDisplay;
                let payoutDeductedClass;

                // For Fund Balance After Payout: Always use the actual payout surplus/deficit if available from daily sim.
                if (data.actualPayoutSurplusDeficit !== null) {
                    fundBalanceDisplay = formatCurrency(data.actualPayoutSurplusDeficit);
                    fundBalanceClass = data.actualPayoutSurplusDeficit >= 0 ? 'text-green-600' : 'text-red-600';
                } else {
                    // This case should ideally not be hit if daily simulation runs correctly for all payouts
                    console.warn(`Payout for Month ${data.month} was not fully processed by daily sim. actualPayoutSurplusDeficit is null.`);
                    fundBalanceDisplay = 'N/A';
                    fundBalanceClass = 'text-gray-500';
                }

                // For Payout Met?: Always use the actual status if available from daily sim.
                if (data.actualPayoutMetStatus !== null) {
                    payoutMetDisplay = data.actualPayoutMetStatus ? 'Met' : 'Shortfall';
                    payoutMetClass = data.actualPayoutMetStatus ? 'text-green-600' : 'text-red-600';
                } else {
                    // This case should ideally not be hit if daily simulation runs correctly for all payouts
                    console.warn(`Payout for Month ${data.month} was not fully processed by daily sim. actualPayoutMetStatus is null.`);
                    payoutMetDisplay = 'N/A';
                    payoutMetClass = 'text-gray-500';
                }

                // For Payout Deducted (J$): Use the actualDeductionForThisPurchaseMonth (set in monthly loop, confirmed by daily)
                if (data.actualDeductionForThisPurchaseMonth !== undefined) {
                    payoutDeductedDisplay = formatCurrency(data.actualDeductionForThisPurchaseMonth);
                    payoutDeductedClass = data.actualDeductionForThisPurchaseMonth > 0 ? 'text-red-600' : 'text-gray-600';
                } else {
                    payoutDeductedDisplay = 'N/A';
                    payoutDeductedClass = 'text-gray-500';
                }


                const row = `
                    <tr>
                        <td class="px-6 py-4 whitespace-nowrap">${data.month}</td>
                        <td class="px-6 py-4 whitespace-nowrap">${data.cashbackDueDate.toLocaleDateString('en-JM', { day: 'numeric', month: 'short', year: 'numeric', timeZone: 'America/Jamaica' })}</td>
                        <td class="px-6 py-4 whitespace-nowrap">${data.payoutMonthEnd.toLocaleDateString('en-JM', { day: 'numeric', month: 'short', year: 'numeric', timeZone: 'America/Jamaica' })}</td>
                        <td class="px-6 py-4 whitespace-nowrap">${formatCurrency(data.accruedNetPayoutObligation)}</td>
                        <td class="px-6 py-4 whitespace-nowrap ${payoutDeductedClass}">${payoutDeductedDisplay}</td> <!-- New cell here -->
                        <td class="px-6 py-4 whitespace-nowrap ${fundBalanceClass}">${fundBalanceDisplay}</td>
                        <td class="px-6 py-4 whitespace-nowrap">
                            <span class="${payoutMetClass}">
                                ${payoutMetDisplay}
                            </span>
                        </td>
                    </tr>
                `;
                combinedPayoutTableBody.insertAdjacentHTML('beforeend', row);
            });
        };


        /**
         * Updates the summary section.
         * @param {number} cumulativeVoucherPurchases - Total voucher purchases.
         * @param {number} totalCashbackOwedAccrued - Total cashback accrued.
         * @param {number} totalCashbackPaid - Total cashback actually paid out.
         * @param {number} finalTradingFund - The trading fund at the end of the simulation.
         * @param {boolean} overallPayoutSuccess - Whether all payouts were met.
         */
        const updateSummary = (cumulativeVoucherPurchases, totalCashbackOwedAccrued, totalCashbackPaid, finalTradingFund, overallPayoutSuccess) => {
            cumulativeVoucherPurchasesSpan.textContent = formatCurrency(cumulativeVoucherPurchases);
            totalCashbackOwedAccruedSpan.textContent = formatCurrency(totalCashbackOwedAccrued);
            totalCashbackPaidSpan.textContent = formatCurrency(totalCashbackPaid);
            netFundPerformanceSpan.textContent = formatCurrency(finalTradingFund);
            netFundPerformanceSpan.classList.toggle('text-green-600', finalTradingFund >= 0);
            netFundPerformanceSpan.classList.toggle('text-red-600', finalTradingFund < 0);

            if (overallPayoutSuccess) {
                overallPayoutStatusSpan.textContent = 'All Payouts Met';
                overallPayoutStatusSpan.className = 'font-bold text-green-600';
            } else {
                overallPayoutStatusSpan.textContent = 'Payout Shortfall Occurred';
                overallPayoutStatusSpan.className = 'font-bold text-red-600';
            }
        };

        // --- Cumulative Daily Simulation Logic ---

        /**
         * Runs the cumulative daily simulation for the entire period, enforcing max 2 trades per week.
         * This function also updates the `actualPayoutSurplusDeficit` and `actualPayoutMetStatus`
         * for each relevant monthly purchase data object based on the daily fund balance.
         * @returns {number} The final capital after all daily events.
         */
        const runCumulativeDailySimulation = () => {
            dailyLogTableBody.innerHTML = ''; // Clear existing rows

            if (monthlyPurchaseData.length === 0) {
                return parseFloat(initialTradingFundInput.value); // Return initial fund if no data
            }

            // Start date for daily log, aligned to Jamaica timezone midnight
            const [year, month, day] = simulationStartDateInput.value.split('-').map(Number);
            const startDate = new Date(Date.UTC(year, month - 1, day, 5, 0, 0)); // 5 hours ahead of Jamaica midnight

            // Determine the absolute end date for the cumulative log: payout month-end of the LAST purchase month
            const lastPurchaseMonthData = monthlyPurchaseData[11]; // Assuming 12 purchase months always
            const endDate = new Date(lastPurchaseMonthData.payoutMonthEnd); // This is already Jamaica-aligned from monthly sim
            endDate.setUTCHours(5, 0, 0, 0); // Ensure it's midnight Jamaica time for comparison

            // Initial capital for the daily log starts with the user's input initial fund
            let currentDailyCapital = parseFloat(initialTradingFundInput.value);

            // Get parameters for daily trading
            const avgWeeklyWin = parseFloat(avgWeeklyWinInput.value) / 100;
            const maxWeeklyLoss = parseFloat(maxWeeklyLossInput.value) / 100;
            const winRate = parseFloat(winRateInput.value);

            // Pre-calculate all trade outcomes for the entire period using the seeded RNG
            const totalDaysInPeriod = Math.ceil((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24)) + 1;
            const totalWeeksInPeriod = Math.ceil(totalDaysInPeriod / 7);
            const maxPossibleTrades = totalWeeksInPeriod * 2; // Max 2 trades per week

            // Re-initialize RNG for daily simulation to ensure consistent daily outcomes for the given seed
            const seedValue = parseInt(simulationSeedInput.value);
            const dailyRng = new SeededRandom(isNaN(seedValue) || simulationSeedInput.value === '' ? Date.now() : seedValue);
            const tradeOutcomes = generateTradeOutcomes(maxPossibleTrades, winRate, dailyRng); // Pass dailyRng here

            let dayCounter = 1;
            let currentDate = new Date(startDate); // Start with the Jamaica-aligned start date

            let tradesThisWeek = 0;

            // Store monthly contribution amounts and their respective purchase dates
            const monthlyContributionsMap = new Map(); // Map: dateString (YYYY-MM-DD) -> contributionAmount
            const monthlyPayoutsMap = new Map(); // Map: dateString (YYYY-MM-DD) -> Array of { monthlyDataRef, netObligation, actualDeduction }

            // Populate contributions and payouts map from monthlyPurchaseData
            const selectedTier = membershipTierInput.value;
            const tierConfig = MEMBERSHIP_TIERS[selectedTier];
            const monthlyVoucherSpend = parseInt(voucherValueInput.value) * parseInt(vouchersPerMonthInput.value);
            const markupRate = parseFloat(markupRateInput.value) / 100;
            const markupAllocationToTradingFund = parseFloat(markupAllocationToTradingFundInput.value) / 100;
            const monthlyTradingFundContribution = monthlyVoucherSpend * markupRate * markupAllocationToTradingFund;
            const oneTimeMembershipFundAddition = tierConfig.fee * 0.50;

            // Month 1 Contribution (includes one-time membership addition)
            if (monthlyPurchaseData.length > 0) {
                const month1PurchaseDate = new Date(monthlyPurchaseData[0].purchaseDate);
                monthlyContributionsMap.set(month1PurchaseDate.toLocaleDateString('en-CA', { year: 'numeric', month: '2-digit', day: '2-digit', timeZone: 'America/Jamaica' }), monthlyTradingFundContribution + oneTimeMembershipFundAddition);

                // Other 11 months contributions (standard monthly contribution)
                for (let i = 1; i < 12; i++) { // Start from month 2 (index 1)
                    const purchaseDate = new Date(monthlyPurchaseData[i].purchaseDate);
                    monthlyContributionsMap.set(purchaseDate.toLocaleDateString('en-CA', { year: 'numeric', month: '2-digit', day: '2-digit', timeZone: 'America/Jamaica' }), monthlyTradingFundContribution);
                }

                // Populate payouts map for all 12 purchase months, including reference to the original monthlyData object
                for (let i = 0; i < 12; i++) {
                    const payoutDate = new Date(monthlyPurchaseData[i].payoutMonthEnd);
                    const payoutDateString = payoutDate.toLocaleDateString('en-CA', { year: 'numeric', month: '2-digit', day: '2-digit', timeZone: 'America/Jamaica' });
                    const payoutInfo = {
                        monthlyDataRef: monthlyPurchaseData[i], // Reference to the actual monthly data object
                        netObligation: monthlyPurchaseData[i].accruedNetPayoutObligation,
                        actualDeduction: monthlyPurchaseData[i].actualDeductionForThisPurchaseMonth
                    };
                    if (monthlyPayoutsMap.has(payoutDateString)) {
                        monthlyPayoutsMap.get(payoutDateString).push(payoutInfo);
                    } else {
                        monthlyPayoutsMap.set(payoutDateString, [payoutInfo]);
                    }
                }
            }


            // Iterate through each day of the cumulative simulation period
            while (currentDate <= endDate) {
                const currentDateString = currentDate.toLocaleDateString('en-CA', { year: 'numeric', month: '2-digit', day: '2-digit', timeZone: 'America/Jamaica' });
                // Get day of week using getUTCDay() as currentDate is UTC-aligned for Jamaica midnight
                const dayOfWeekJamaica = currentDate.getUTCDay(); // 0 = Sunday, 1 = Monday, ..., 6 = Saturday
                const isWeekday = (dayOfWeekJamaica >= 1 && dayOfWeekJamaica <= 5); // Monday-Friday

                // Reset trades for the week if it's a new week (Monday or the very first day if it's not Monday)
                if (dayOfWeekJamaica === 1 || dayCounter === 1) {
                    tradesThisWeek = 0;
                }

                let eventOccurred = false;
                let eventType = 'No Event';
                let dailyNetChange = 0; // Net change for the 'Net Change (J$)' column

                // Store capital before any events for this specific day
                let capitalBeforeEvent = currentDailyCapital;

                // 1. Apply Contributions for the day
                const contributionForToday = monthlyContributionsMap.get(currentDateString);
                if (contributionForToday) {
                    currentDailyCapital += contributionForToday;
                    dailyNetChange += contributionForToday; // Contributions also add to net change
                    eventOccurred = true;
                    eventType = 'Contribution';
                }

                // 2. Apply Payouts for the day (if any are due)
                const payoutsDueToday = monthlyPayoutsMap.get(currentDateString);
                const isPayoutDay = payoutsDueToday && payoutsDueToday.length > 0;

                if (isPayoutDay) {
                    payoutsDueToday.forEach(payout => {
                        currentDailyCapital -= payout.actualDeduction; // Deduct actual amount from fund
                        dailyNetChange -= payout.actualDeduction; // Payouts are negative change

                        // Update the original monthly data object with the actual fund balance and status from daily sim
                        const originalMonthlyData = payout.monthlyDataRef;
                        originalMonthlyData.actualPayoutSurplusDeficit = currentDailyCapital;
                        originalMonthlyData.actualPayoutMetStatus = (currentDailyCapital >= 0 || (currentDailyCapital < 0 && originalMonthlyData.accruedNetPayoutObligation === 0));
                    });
                    eventOccurred = true;
                    if (eventType === 'No Event') eventType = 'Cashback Payout';
                    else eventType += ' & Payout'; // If other events occurred, append
                }

                // 3. Simulate Trading for the day (if it's an eligible trading day and a trade is scheduled)
                // A day is a "Trading Day?" only if it's a weekday AND it's a designated trade day AND no other events occurred.
                let isTradingDayForDisplay = false; // Default to false

                // A trade occurs if it's a weekday, no other events, we haven't hit the weekly trade limit,
                // AND the currentDailyCapital is positive.
                const canTradeOnThisDay = isWeekday && !contributionForToday && !isPayoutDay && tradesThisWeek < 2 && currentDailyCapital > 0;

                if (canTradeOnThisDay && tradeOutcomes.length > 0) {
                    // Consume a pre-generated trade outcome if eligible for a trade
                    const isWin = tradeOutcomes.shift(); // Use shift to consume from the beginning of the pre-generated array
                    const capitalForTradeCalculation = currentDailyCapital; // Use current capital for percentage calculation

                    let tradeGainLossAmount;
                    if (isWin) {
                        tradeGainLossAmount = capitalForTradeCalculation * avgWeeklyWin;
                        if (eventType === 'No Event') eventType = 'Trade (Win)';
                        else eventType += ' & Trade (Win)';
                    } else {
                        tradeGainLossAmount = -capitalForTradeCalculation * maxWeeklyLoss;
                        if (eventType === 'No Event') eventType = 'Trade (Loss)';
                        else eventType += ' & Trade (Loss)';
                    }
                    currentDailyCapital += tradeGainLossAmount;
                    dailyNetChange += tradeGainLossAmount;
                    eventOccurred = true;
                    tradesThisWeek++; // Increment trade count for the current week
                    isTradingDayForDisplay = true; // Mark as a trading day for display
                }

                const row = `
                    <tr>
                        <td class="px-6 py-4 whitespace-nowrap">${dayCounter}</td>
                        <td class="px-6 py-4 whitespace-nowrap">${currentDate.toLocaleDateString('en-JM', { month: 'short', day: 'numeric', year: 'numeric', timeZone: 'America/Jamaica' })}</td>
                        <td class="px-6 py-4 whitespace-nowrap">${currentDate.toLocaleDateString('en-JM', { weekday: 'short', timeZone: 'America/Jamaica' })}</td>
                        <td class="px-6 py-4 whitespace-nowrap">
                            ${isTradingDayForDisplay ? 'Yes' : 'No'}
                        </td>
                        <td class="px-6 py-4 whitespace-nowrap">
                            ${eventOccurred ? 'Yes' : 'No'}
                        </td>
                        <td class="px-6 py-4 whitespace-nowrap">
                            <span class="${eventType.includes('Win') ? 'text-green-600' : (eventType.includes('Loss') || eventType.includes('Payout') ? 'text-red-600' : 'text-gray-500')}">
                                ${eventType}
                            </span>
                        </td>
                        <td class="px-6 py-4 whitespace-nowrap ${dailyNetChange >= 0 ? 'text-green-600' : 'text-red-600'}">${formatCurrency(dailyNetChange)}</td>
                        <td class="px-6 py-4 whitespace-nowrap">${formatCurrency(capitalBeforeEvent)}</td>
                        <td class="px-6 py-4 whitespace-nowrap">${formatCurrency(currentDailyCapital)}</td>
                    </tr>
                `;
                dailyLogTableBody.insertAdjacentHTML('beforeend', row);

                currentDate.setDate(currentDate.getDate() + 1);
                dayCounter++;
            }
            return currentDailyCapital; // Return the final capital
        };


        // New helper function to set the default initial trading fund input value
        function updateInitialTradingFundDefault() {
            // This function now only ensures the input is 0 if it's currently 0 or empty,
            // and does NOT attempt to calculate a default based on monthly contributions.
            // The initial fund is purely user-defined.
            const currentInputValue = parseFloat(initialTradingFundInput.value);
            if (isNaN(currentInputValue) || currentInputValue === 0) {
                initialTradingFundInput.value = '0';
            }
        }


        // --- Event Listeners and Initial Setup ---

        // Attach event listeners to all input fields to re-run simulation
        simulationStartDateInput.addEventListener('change', runSimulation);
        voucherValueInput.addEventListener('change', runSimulation);
        vouchersPerMonthInput.addEventListener('change', runSimulation);
        markupRateInput.addEventListener('input', runSimulation);
        markupAllocationToTradingFundInput.addEventListener('input', runSimulation);
        initialTradingFundInput.addEventListener('input', runSimulation); // Keep this for manual changes
        avgWeeklyWinInput.addEventListener('input', runSimulation);
        maxWeeklyLossInput.addEventListener('input', runSimulation);
        winRateInput.addEventListener('input', runSimulation);
        simulationSeedInput.addEventListener('input', runSimulation); // New: Listen to seed changes
        stressTestModeCheckbox.addEventListener('change', runSimulation);

        // Set default start date to today and run initial simulation
        document.addEventListener('DOMContentLoaded', () => {
            const today = new Date();
            // Get today's date components in Jamaica timezone
            const jamaicaTime = new Date(today.toLocaleString('en-US', { timeZone: 'America/Jamaica' }));
            const year = jamaicaTime.getFullYear();
            const month = (jamaicaTime.getMonth() + 1).toString().padStart(2, '0');
            const day = jamaicaTime.getDate().toString().padStart(2, '0');
            simulationStartDateInput.value = `${year}-${month}-${day}`;

            // Set the initial default value for initialTradingFundInput on load
            updateInitialTradingFundDefault(); // Ensure it's 0 or user's last input
            runSimulation(); // Run simulation on initial page load
        });

        // Update parameters based on membership tier selection
        membershipTierInput.addEventListener('change', runSimulation); // No longer calls updateInitialTradingFundDefault
    </script>
</body>
</html>
