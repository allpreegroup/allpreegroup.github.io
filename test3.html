<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cashback Payout + Trading Simulation</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inter Font -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
 
    <style> 
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4ff;
            color: #333;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 2rem;
        }
        .container {
            background-color: #ffffff;
            border-radius: 1.5rem;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            padding: 2.5rem;
            max-width: 1200px;
            width: 100%;
            margin-top: 2rem;
        }
        h1 {
            font-size: 2.5rem;
            font-weight: 800;
            color: #1a202c;
            text-align: center;
            margin-bottom: 2rem;
        }
        .input-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }
        .input-field {
            display: flex;
            flex-direction: column;
        }
        label {
            display: block;
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: #4a5568;
        }
        input[type="number"], input[type="date"], select {
            width: 100%;
            padding: 0.75rem 1rem;
            border: 1px solid #e2e8f0;
            border-radius: 0.5rem;
            font-size: 1rem;
            color: #333;
            transition: border-color 0.2s, box-shadow 0.2s;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%236B7280%22%20d%3D%22M287%2C197.3L159.2%2C69.5c-3.2-3.2-8.4-3.2-11.6%2C0L5.4%2C197.3c-3.2%2C3.2-3.2%2C8.4%2C0%2C11.6l11.6%2C11.6c3.2%2C3.2%2C8.4%2C3.2%2C11.6%2C0l124.6-124.6l124.6%2C124.6c3.2%2C3.2%2C8.4%2C3.2%2C11.6%2C0l11.6-11.6C290.2%2C205.7%2C290.2%2C200.5%2C287%2C197.3z%22%2F%3E%3C%2Fsvg%3E');
            background-repeat: no-repeat;
            background-position: right 0.75rem center;
            background-size: 0.8rem auto;
        }
        input[type="date"] {
            background-image: none;
        }
        input[type="number"]::-webkit-outer-spin-button,
        input[type="number"]::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        input[type="number"] {
            -moz-appearance: textfield;
        }
        input[type="number"]:focus, input[type="date"]:focus, select:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.25);
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 2rem;
        }
        th, td {
            padding: 0.75rem 1rem;
            border: 1px solid #e2e8f0;
            text-align: left;
            font-size: 0.875rem; /* Default font size for table cells */
        }
        th {
            background-color: #e0f2fe;
            color: #2c5282;
            font-weight: 700;
            text-transform: uppercase;
            font-size: 0.875rem;
        }
        tbody tr:nth-child(odd) {
            background-color: #f8fafc;
        }
        tbody tr:hover {
            background-color: #eef7ff;
        }
        .summary {
            margin-top: 2rem;
            padding: 1.5rem;
            background-color: #e0f2fe;
            border-radius: 0.75rem;
            text-align: center;
            font-size: 1.25rem;
            font-weight: 600;
            color: #2c5282;
        }
        .summary span {
            color: #007bff;
            font-weight: 700;
        }
        .text-green-600 {
            color: #22c55e;
        }
        .text-red-600 {
            color: #ef4444;
        }
        .text-orange-600 {
            color: #f97316;
        }
        .stress-test-checkbox {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-top: 1rem;
        }
        .stress-test-checkbox input[type="checkbox"] {
            width: auto;
            margin: 0;
        }
        .table-container {
            margin-top: 2rem;
            background-color: #ffffff;
            border-radius: 1.5rem;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            padding: 1.5rem;
        }
        .table-container h2 {
            font-size: 1.5rem;
            font-weight: 700;
            color: #1a202c;
            text-align: center;
            margin-bottom: 1.5rem;
        }
        .daily-log-section {
            margin-top: 3rem;
            padding-top: 2rem;
            border-top: 1px solid #e2e8f0;
        }
        .daily-log-section h2 {
            font-size: 2rem;
            font-weight: 800;
            color: #1a202c;
            text-align: center;
            margin-bottom: 1.5rem;
        }
        .daily-log-controls {
            display: flex;
            justify-content: center;
            margin-bottom: 1.5rem;
        }
        .daily-log-controls select {
            width: auto;
            min-width: 250px;
        }

        /* New styles for Reserve Flow Calculator */
        .reserve-flow-section {
            margin-top: 3rem;
            padding-top: 2rem;
            border-top: 1px solid #e2e8f0;
        }
        .reserve-flow-section h2 {
            font-size: 2rem;
            font-weight: 800;
            color: #1a202c;
            text-align: center;
            margin-bottom: 1.5rem;
        }
        .reserve-flow-input-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }
        .reserve-flow-table-container, .main-simulation-sales-table-container {
            margin-top: 1.5rem;
            background-color: #ffffff;
            border-radius: 1.5rem;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            padding: 1.5rem;
        }
        .reserve-flow-table-container h3, .main-simulation-sales-table-container h3 {
            font-size: 1.25rem;
            font-weight: 700;
            color: #1a202c;
            margin-bottom: 1rem;
        }

        @media (max-width: 768px) {
            body {
                padding: 1rem;
            }
            .container {
                padding: 1.5rem;
            }
            h1 {
                font-size: 2rem;
            }
            .input-grid, .reserve-flow-input-grid {
                grid-template-columns: 1fr;
            }
            th, td {
                padding: 0.5rem 0.75rem;
                font-size: 0.75rem;
            }
            .summary {
                font-size: 1rem;
                padding: 1rem;
            }
            .daily-log-section h2, .reserve-flow-section h2 {
                font-size: 1.5rem;
            }
            .daily-log-controls {
                flex-direction: column;
                align-items: center;
            }
            .daily-log-controls select {
                width: 100%;
                margin-bottom: 1rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Cashback Payout + Trading Simulation</h1>
        <p class="text-center text-gray-600 mb-6">Model the growth of a trading fund and its ability to cover delayed cashback payouts.</p>

        <div class="input-grid">
            <div class="input-field">
                <label for="membershipTier">Membership Tier:</label>
                <select id="membershipTier">
                    <option value="Free">Free</option>
                    <option value="Standard">Standard</option>
                    <option value="Premium" selected>Premium</option>
                </select>
            </div>
            <div class="input-field">
                <label for="simulationStartDate">Simulation Start Date:</label>
                <input type="date" id="simulationStartDate">
            </div>
            <div class="input-field">
                <label for="numberOfPurchaseMonths"># Of Months:</label>
                <input type="number" id="numberOfPurchaseMonths" value="1" min="1" max="60">
            </div>
            <!-- Removed Voucher Value and Vouchers per Month dropdowns -->
            <div class="input-field">
                <label for="markupRate">Markup Rate (%):</label>
                <input type="number" id="markupRate" value="25" min="0" max="100" step="1">
            </div>
            <div class="input-field">
                <label for="markupAllocationToTradingFund">Allocation to Fund (%):</label>
                <input type="number" id="markupAllocationToTradingFund" value="17" min="0" max="100" step="1">
            </div>
            <div class="input-field">
                <label for="initialTradingFund">Trading Fund (J$):</label>
                <input type="number" id="initialTradingFund" value="0" min="0" step="100" title="This is the fund balance at the very start of the simulation, before any monthly contributions are added.">
            </div>
            <div class="input-field">
                <label for="avgWeeklyWin">Max Win (%):</label>
                <input type="number" id="avgWeeklyWin" value="6" min="0" max="100" step="0.01">
            </div>
            <div class="input-field">
                <label for="maxWeeklyLoss">Max Loss (%):</label>
                <input type="number" id="maxWeeklyLoss" value="5" min="0" max="100" step="1">
            </div>
            <div class="input-field">
                <label for="winRate">Win Rate (%):</label>
                <input type="number" id="winRate" value="53.4" min="0" max="100" step="0.1">
            </div>
            <div class="input-field">
                <label for="simulationSeed">Seed:</label>
                <input type="number" id="simulationSeed" value="1" placeholder="Enter a number for consistent results">
            </div>
            <div class="input-field stress-test-checkbox">
                <input type="checkbox" id="stressTestMode">
                <label for="stressTestMode" class="mb-0">Stress Test</label>
            </div>
        </div>

        <!-- NEW: Monthly Voucher Sales Input for Main Simulation -->
        <div class="main-simulation-sales-table-container">
            <h3>Monthly Voucher Sales Input (Quantities for Simulation)</h3>
            <div class="overflow-x-auto">
                <table id="mainSimulationMonthlySalesInputTable" class="min-w-full divide-y divide-gray-200">
                    <thead>
                        <tr id="mainSimulationMonthlySalesInputHeader">
                            <th class="px-6 py-3">Voucher Type</th>
                            <!-- Month headers will be generated here -->
                        </tr>
                    </thead>
                    <tbody>
                        <tr id="mainSimulation10kVoucherRow">
                            <td class="px-6 py-4 whitespace-nowrap">J$10K Voucher</td>
                            <!-- Input fields for months will be generated here -->
                        </tr>
                        <tr id="mainSimulation15kVoucherRow">
                            <td class="px-6 py-4 whitespace-nowrap">J$15K Voucher</td>
                            <!-- Input fields for months will be generated here -->
                        </tr>
                        <tr id="mainSimulation20kVoucherRow">
                            <td class="px-6 py-4 whitespace-nowrap">J$20K Voucher</td>
                            <!-- Input fields for months will be generated here -->
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>
        <!-- END NEW: Monthly Voucher Sales Input for Main Simulation -->

        <div class="summary">
            <h2 class="text-xl font-bold mb-4">Simulation Summary</h2>
            <p>Cumulative Voucher Purchases: <span id="cumulativeVoucherPurchases" class="font-bold">J$0</span></p>
            <p>Total Cashback Owed (Accrued): <span id="totalCashbackOwedAccrued" class="font-bold">J$0</span></p>
            <p>Total Cashback Paid: <span id="totalCashbackPaid" class="font-bold">J$0</span></p>
            <p>Net Fund Performance: <span id="netFundPerformance" class="font-bold">J$0</span></p>
            <p>Overall Payout Status: <span id="overallPayoutStatus" class="font-bold"></span></p>
        </div>

        <div class="table-container">
            <h2>Payout Obligation & Fund Performance</h2>
            <div class="overflow-x-auto">
                <table id="combinedPayoutTable" class="min-w-full divide-y divide-gray-200">
                    <thead>
                        <tr>
                            <th class="px-6 py-3">Month</th>
                            <th class="px-6 py-3">Purchase Date</th>
                            <th class="px-6 py-3">Monthly Fund Contribution (J$)</th>
                            <th class="px-6 py-3">Cashback Due Date</th>
                            <th class="px-6 py-3">Payout Month-End</th>
                            <th class="px-6 py-3">Net Payout Obligation (J$)</th>
                            <th class="px-6 py-3">Payout Deducted (J$)</th>
                            <th class="px-6 py-3">Fund Balance After Payout (J$)</th>
                            <th class="px-6 py-3">Payout Met?</th>
                        </tr>
                    </thead>
                    <tbody>
                        <!-- Combined Payout rows will be generated here -->
                    </tbody>
                </table>
            </div>
        </div>

        <!-- NEW SECTION: Reserve Flow Calculator -->
        <div class="reserve-flow-section">
            <h2>Reserve Flow Calculator</h2>
            <p class="text-center text-gray-600 mb-6">Model the reserve fund's ability to cover cashback payouts with a 121-day delay, based on daily financial movements.</p>

            <!-- Removed Upfront Buffer Input -->
            <div class="reserve-flow-input-grid">
                <!-- This grid will now be empty or contain other future inputs -->
            </div>

            <div class="reserve-flow-table-container">
                <h3>Voucher Type Definitions (Calculated)</h3>
                <div class="overflow-x-auto">
                    <table id="rfVoucherDefinitionsTable" class="min-w-full divide-y divide-gray-200">
                        <thead>
                            <tr>
                                <th class="px-6 py-3">Voucher Type</th>
                                <th class="px-6 py-3">Markup per Voucher (J$)</th>
                                <th class="px-6 py-3">Cashback per Voucher (J$)</th>
                            </tr>
                        </thead>
                        <tbody id="rfVoucherDefinitionsTableBody">
                            <!-- Dynamic rows will be generated here -->
                        </tbody>
                    </table>
                </div>
            </div>

            <div class="reserve-flow-table-container">
                <h3>Monthly Voucher Sales Input (Quantities)</h3>
                <div class="overflow-x-auto">
                    <table id="rfMonthlySalesInputTable" class="min-w-full divide-y divide-gray-200">
                        <thead>
                            <tr id="rfMonthlySalesInputHeader">
                                <th class="px-6 py-3">Voucher Type</th>
                                <!-- Month headers will be generated here -->
                            </tr>
                        </thead>
                        <tbody>
                            <tr id="rf10kVoucherRow">
                                <td class="px-6 py-4 whitespace-nowrap">J$10K Voucher</td>
                                <!-- Display fields for months will be generated here -->
                            </tr>
                            <tr id="rf15kVoucherRow">
                                <td class="px-6 py-4 whitespace-nowrap">J$15K Voucher</td>
                                <!-- Display fields for months will be generated here -->
                            </tr>
                            <tr id="rf20kVoucherRow">
                                <td class="px-6 py-4 whitespace-nowrap">J$20K Voucher</td>
                                <!-- Display fields for months will be generated here -->
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>

            <div class="reserve-flow-table-container">
                <h3>Monthly Financials (Calculated)</h3>
                <div class="overflow-x-auto">
                    <table id="rfMonthlyFinancialsTable" class="min-w-full divide-y divide-gray-200">
                        <thead>
                            <tr id="rfMonthlyFinancialsHeader">
                                <th class="px-6 py-3">Financial Metric</th>
                                <!-- Month headers will be generated here -->
                            </tr>
                        </thead>
                        <tbody>
                            <tr id="rfTotalGrossMarkupRow">
                                <td class="px-6 py-4 whitespace-nowrap">Gross Markup from Sales (J$)</td>
                                <!-- Calculated values for months will be generated here -->
                            </tr>
                            <tr id="rfAllocatedMarkupAddedRow">
                                <td class="px-6 py-4 whitespace-nowrap">Allocated Markup Added to Reserve (J$)</td>
                                <!-- Calculated values for months will be generated here -->
                            </tr>
                            <tr id="rfTotalCashbackOwedRow">
                                <td class="px-6 py-4 whitespace-nowrap">Total Cashback Owed (J$) (Liability Incurred)</td>
                                <!-- Calculated values for months will be generated here -->
                            </tr>
                            <tr id="rfActualCashbackPaidOutRow">
                                <td class="px-6 py-4 whitespace-nowrap">Actual Cashback Paid Out (J$) (121-day delay)</td>
                                <!-- Calculated values for months will be generated here -->
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>

            <div class="reserve-flow-table-container">
                <h3>Reserve Flow (Daily)</h3>
                <div class="overflow-x-auto">
                    <table id="rfReserveFlowTable" class="min-w-full divide-y divide-gray-200">
                        <thead>
                            <tr>
                                <th class="px-6 py-3">Day</th>
                                <th class="px-6 py-3">Date</th>
                                <th class="px-6 py-3">Reserve Start (J$)</th>
                                <th class="px-6 py-3">Add Reserve (+ Markup) (J$)</th>
                                <th class="px-6 py-3">Pay Cashback (â€“ Owed) (J$)</th>
                                <th class="px-6 py-3">Total Reserve (J$)</th>
                                <th class="px-6 py-3">Total Owed Liability (J$)</th>
                                <th class="px-6 py-3">Net Reserve Coverage (J$)</th>
                                <th class="px-6 py-3">Status</th>
                            </tr>
                        </thead>
                        <tbody>
                            <!-- Daily Reserve flow rows will be generated here -->
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
        <!-- END NEW SECTION: 12-Month Reserve Flow Calculator -->

        <div class="daily-log-section">
            <h2>Cumulative Daily Trading Log</h2>
            <div class="overflow-x-auto">
                <table id="dailyLogTable" class="min-w-full divide-y divide-gray-200">
                    <thead>
                        <tr>
                            <th class="px-6 py-3">Day</th>
                            <th class="px-6 py-3">Date</th>
                            <th class="px-6 py-3">Day of Week</th>
                            <th class="px-6 py-3">Trading Day?</th>
                            <th class="px-6 py-3">Event Occurred?</th>
                            <th class="px-6 py-3">Event Type</th>
                            <th class="px-6 py-3">Net Change (J$)</th>
                            <th class="px-6 py-3">Capital Before Event (J$)</th>
                            <th class="px-6 py-3">Capital After Event (J$)</th>
                        </tr>
                    </thead>
                <tbody>
                    <!-- Daily log rows will be generated here -->
                </tbody>
                </table>
            </div>
        </div>

    </div>

    <script>
        // --- Constants and Configuration (Existing Simulation) ---
        const PAYOUT_DELAY_DAYS = 121;
        const TRADING_WEEKS_PER_MONTH = 8;
        const MAX_TRADES_PER_WEEK = 2;
        const EXTRA_MONTHS_FOR_PAYOUTS = Math.ceil(PAYOUT_DELAY_DAYS / 30.4375) + 1; // Approx 4 + 1 = 5 months

        const MEMBERSHIP_TIERS = {
            'Free': {
                fee: 0,
                cashbackRates: { 10000: 0.30, 15000: 0.30, 20000: 0.30 }
            },
            'Standard': {
                fee: 4200,
                cashbackRates: { 10000: 0.33, 15000: 0.34, 20000: 0.36 }
            },
            'Premium': {
                fee: 8400,
                cashbackRates: { 10000: 0.37, 15000: 0.41, 20000: 0.49 }
            }
        };

        // Define fixed voucher values for calculations
        const VOUCHER_VALUES = {
            '10k': 10000,
            '15k': 15000,
            '20k': 20000
        };

        // --- DOM Elements (Existing Simulation) ---
        const membershipTierInput = document.getElementById('membershipTier');
        const simulationStartDateInput = document.getElementById('simulationStartDate');
        const numberOfPurchaseMonthsInput = document.getElementById('numberOfPurchaseMonths');
        const markupRateInput = document.getElementById('markupRate');
        const markupAllocationToTradingFundInput = document.getElementById('markupAllocationToTradingFund');
        const initialTradingFundInput = document.getElementById('initialTradingFund');
        const avgWeeklyWinInput = document.getElementById('avgWeeklyWin');
        const maxWeeklyLossInput = document.getElementById('maxWeeklyLoss');
        const winRateInput = document.getElementById('winRate');
        const simulationSeedInput = document.getElementById('simulationSeed');
        const stressTestModeCheckbox = document.getElementById('stressTestMode');

        const cumulativeVoucherPurchasesSpan = document.getElementById('cumulativeVoucherPurchases');
        const totalCashbackOwedAccruedSpan = document.getElementById('totalCashbackOwedAccrued');
        const totalCashbackPaidSpan = document.getElementById('totalCashbackPaid');
        const netFundPerformanceSpan = document.getElementById('netFundPerformance');
        const overallPayoutStatusSpan = document.getElementById('overallPayoutStatus');

        const combinedPayoutTableBody = document.querySelector('#combinedPayoutTable tbody');
        const dailyLogTableBody = document.querySelector('#dailyLogTable tbody');

        // New DOM elements for main simulation monthly sales input
        const mainSimulationMonthlySalesInputHeader = document.getElementById('mainSimulationMonthlySalesInputHeader');
        const mainSimulation10kVoucherRow = document.getElementById('mainSimulation10kVoucherRow');
        const mainSimulation15kVoucherRow = document.getElementById('mainSimulation15kVoucherRow');
        const mainSimulation20kVoucherRow = document.getElementById('mainSimulation20kVoucherRow');


        let monthlySimulationResults = []; // Stores results for daily log selection (includes extended months)
        let monthlyPurchaseData = []; // Stores only the purchase data for display in combinedPayoutTable
        let dailyReserveFlowLog = []; // New: Stores daily reserve flow entries
        let _monthlyMarkupForReserve = []; // Global variable to store monthly allocated markup for reserve

        // --- Seeded Random Number Generator ---
        class SeededRandom {
            constructor(seed) {
                this.seed = seed % 2147483647;
                if (this.seed <= 0) this.seed += 2147483646;
            }

            next() {
                this.seed = (this.seed * 16807) % 2147483647;
                return (this.seed - 1) / 2147483646;
            }
        }

        let rng = null; // Global instance of the seeded random generator

        // --- Helper Functions ---

        /**
         * Formats a number as Jamaican Dollar currency.
         * @param {number} amount - The amount to format.
         * @param {boolean} forDailyReserve - Whether to format for the daily reserve table (more decimals).
         * @returns {string} The formatted currency string.
         */
        const formatCurrency = (amount, forDailyReserve = false) => {
            const options = {
                style: 'currency',
                currency: 'JMD',
                minimumFractionDigits: 0,
                maximumFractionDigits: 0
            };
            if (forDailyReserve) {
                options.minimumFractionDigits = 2;
                options.maximumFractionDigits = 2;
            }
            return new Intl.NumberFormat('en-JM', options).format(amount);
        };

        /**
         * Adds a specified number of days to a Date object.
         * @param {Date} date - The starting Date object.
         * @param {number} days - The number of days to add.
         * @returns {Date} A new Date object with the added days.
         */
        const addDays = (date, days) => {
            const result = new Date(date);
            result.setDate(result.getDate() + days);
            return result;
        };

        /**
         * Gets the last day of the month for a given date (local time).
         * @param {Date} date - The Date object.
         * @returns {Date} A new Date object representing the last day of the month.
         */
        const getEndOfMonthLocal = (date) => {
            const d = new Date(date.getFullYear(), date.getMonth() + 1, 1); // First day of next month
            d.setDate(d.getDate() - 1); // Last day of current month
            d.setHours(0, 0, 0, 0); // Normalize to local midnight
            return d;
        };

        /**
         * Generates a shuffled array of win/loss outcomes for a given number of trades.
         * Ensures the exact win rate is met.
         * @param {number} totalTrades - Total number of trades.
         * @param {number} winRatePercent - Win rate as a percentage (e.g., 60).
         * @param {SeededRandom} rngInstance - The seeded random number generator instance.
         * @returns {boolean[]} An array where true is a win, false is a loss.
         */
        const generateTradeOutcomes = (totalTrades, winRatePercent, rngInstance) => {
            const numWins = Math.round(totalTrades * (winRatePercent / 100));
            const numLosses = totalTrades - numWins;

            const outcomes = [];
            for (let i = 0; i < numWins; i++) {
                outcomes.push(true); // Win
            }
            for (let i = 0; i < numLosses; i++) {
                outcomes.push(false); // Loss
            }

            // Shuffle the array (Fisher-Yates algorithm) using the seeded RNG
            for (let i = outcomes.length - 1; i > 0; i--) {
                const j = Math.floor(rngInstance.next() * (i + 1));
                [outcomes[i], outcomes[j]] = [outcomes[j], outcomes[i]];
            }
            return outcomes;
        };

        // --- Main Simulation Logic (Monthly) ---

        const runSimulation = () => {
            // 1. Read Input Parameters
            const selectedTier = membershipTierInput.value;
            const simulationStartDateString = simulationStartDateInput.value;
            const numberOfPurchaseMonths = parseInt(numberOfPurchaseMonthsInput.value);
            const markupRate = parseFloat(markupRateInput.value) / 100;
            const markupAllocationToTradingFund = parseFloat(markupAllocationToTradingFundInput.value) / 100;
            let avgWeeklyWin = parseFloat(avgWeeklyWinInput.value) / 100;
            let maxWeeklyLoss = parseFloat(maxWeeklyLossInput.value) / 100;
            let winRate = parseFloat(winRateInput.value);

            const isStressTestMode = stressTestModeCheckbox.checked;

            if (isStressTestMode) {
                avgWeeklyWin *= 0.8;
                maxWeeklyLoss *= 1.2;
                winRate = Math.max(0, winRate - 10);
            }

            const tierConfig = MEMBERSHIP_TIERS[selectedTier];
            const membershipFee = tierConfig.fee;

            // Get monthly sales inputs for main simulation
            const mainSimMonthlySales = Array.from({ length: numberOfPurchaseMonths }, () => ({ '10k': 0, '15k': 0, '20k': 0 }));
            document.querySelectorAll('#mainSimulationMonthlySalesInputTable .main-sim-sales-input').forEach(input => {
                const voucherType = input.dataset.voucher;
                const monthIndex = parseInt(input.dataset.month);
                if (monthIndex < numberOfPurchaseMonths) { // Ensure we only read for active months
                    mainSimMonthlySales[monthIndex][voucherType] = parseInt(input.value) || 0;
                }
            });

            const monthlyVoucherSpends = [];
            const monthlyMarkupAmounts = [];
            const monthlyTradingFundContributions = [];
            const monthlyCashbackOwedAmounts = [];

            let cumulativeVoucherPurchases = 0;
            let totalCashbackOwedAccrued = 0;

            for (let i = 0; i < numberOfPurchaseMonths; i++) {
                const sales = mainSimMonthlySales[i];
                let currentMonthVoucherSpend = 0;
                let currentMonthMarkup = 0;
                let currentMonthCashbackOwed = 0;

                for (const key in VOUCHER_VALUES) {
                    const voucherValue = VOUCHER_VALUES[key];
                    const quantity = sales[key];
                    currentMonthVoucherSpend += voucherValue * quantity;
                    currentMonthMarkup += (voucherValue * quantity) * markupRate;
                    currentMonthCashbackOwed += (voucherValue * quantity) * tierConfig.cashbackRates[voucherValue];
                }

                monthlyVoucherSpends.push(currentMonthVoucherSpend);
                monthlyMarkupAmounts.push(currentMonthMarkup);
                monthlyCashbackOwedAmounts.push(currentMonthCashbackOwed);

                cumulativeVoucherPurchases += currentMonthVoucherSpend;
                totalCashbackOwedAccrued += Math.max(0, currentMonthCashbackOwed - (currentMonthMarkup * (1 - markupAllocationToTradingFund)));
            }

            const membershipAllocationToTradingFund = 0.50;
            const oneTimeMembershipFundAddition = membershipFee * membershipAllocationToTradingFund;

            // Calculate monthly trading fund contributions
            for (let i = 0; i < numberOfPurchaseMonths; i++) {
                let contribution = monthlyMarkupAmounts[i] * markupAllocationToTradingFund;
                if (i === 0) {
                    contribution += oneTimeMembershipFundAddition;
                }
                monthlyTradingFundContributions.push(contribution);
            }

            // Calculate monthly markup allocated to reserve for the Reserve Flow
            _monthlyMarkupForReserve = monthlyMarkupAmounts.map(markup => markup * RF_MARKUP_ALLOCATION_TO_RESERVE);


            let currentTradingFundAtStartOfMonth = parseFloat(initialTradingFundInput.value);

            const seedValue = parseInt(simulationSeedInput.value);
            rng = new SeededRandom(isNaN(seedValue) || simulationSeedInput.value === '' ? Date.now() : seedValue);

            // Parse Start Date to be consistently at local midnight
            let initialDate;
            if (simulationStartDateString) {
                initialDate = new Date(simulationStartDateString);
            } else {
                initialDate = new Date(); // Default to today
            }
            initialDate.setHours(0, 0, 0, 0); // Normalize to local midnight

            monthlySimulationResults = [];
            monthlyPurchaseData = [];
            
            const actualPurchaseMonths = numberOfPurchaseMonths; // Use the input value
            const currentTotalSimulationMonths = actualPurchaseMonths + EXTRA_MONTHS_FOR_PAYOUTS;

            // --- Monthly Simulation Loop (Extended to cover all payouts) ---
            for (let monthIndex = 0; monthIndex < currentTotalSimulationMonths; monthIndex++) {
                const monthData = {
                    actualPayoutSurplusDeficit: null,
                    actualPayoutMetStatus: null,
                    payoutDeductedInThisMonth: 0,
                    actualDeductionForThisPurchaseMonth: 0
                };

                // Only process purchase-related data for actual purchase months
                if (monthIndex < actualPurchaseMonths) {
                    const purchaseDate = new Date(initialDate.getFullYear(), initialDate.getMonth() + monthIndex, initialDate.getDate());
                    purchaseDate.setHours(0, 0, 0, 0); // Normalize to local midnight
                    monthData.purchaseDate = purchaseDate;
                    monthData.totalCashbackOwed = monthlyCashbackOwedAmounts[monthIndex];
                    monthData.cashbackAccruedThisMonth = monthData.totalCashbackOwed;
                    // Net Payout Obligation is total owed minus markup not allocated to fund
                    monthData.accruedNetPayoutObligation = Math.max(0, monthlyCashbackOwedAmounts[monthIndex] - (monthlyMarkupAmounts[monthIndex] * (1 - markupAllocationToTradingFund)));
                } else {
                    monthData.purchaseDate = null;
                    monthData.cashbackAccruedThisMonth = 0;
                    monthData.accruedNetPayoutObligation = 0;
                }

                const currentMonthDate = new Date(initialDate.getFullYear(), initialDate.getMonth() + monthIndex, initialDate.getDate());
                currentMonthDate.setHours(0, 0, 0, 0); // Normalize to local midnight
                monthData.month = monthIndex + 1;
                monthData.cashbackDueDate = new Date(); // Placeholder
                monthData.payoutMonthEnd = getEndOfMonthLocal(currentMonthDate); // Set payoutMonthEnd for all months in sim

                let monthlyContributionForCurrentMonth = (monthIndex < actualPurchaseMonths) ? monthlyTradingFundContributions[monthIndex] : 0;
                monthData.monthlyFundContribution = monthlyContributionForCurrentMonth;

                monthData.startingTradingCapital = currentTradingFundAtStartOfMonth;
                let capitalForTradingThisMonth = currentTradingFundAtStartOfMonth + monthlyContributionForCurrentMonth;

                const tradeOutcomes = generateTradeOutcomes(TRADING_WEEKS_PER_MONTH, winRate, rng);
                let fundAfterTrades = capitalForTradingThisMonth;

                for (let week = 0; week < TRADING_WEEKS_PER_MONTH; week++) {
                    const isWin = tradeOutcomes[week];
                    let gainLossAmount;
                    const capitalForTradeCalculation = fundAfterTrades;

                    if (isWin) {
                        gainLossAmount = capitalForTradeCalculation * avgWeeklyWin;
                    } else {
                        gainLossAmount = -capitalForTradeCalculation * maxWeeklyLoss;
                    }
                    fundAfterTrades += gainLossAmount;
                }

                monthData.endingTradingCapitalBeforePayout = fundAfterTrades;

                const currentSimMonthEnd = getEndOfMonthLocal(currentMonthDate);

                for (let i = 0; i < monthlySimulationResults.length; i++) {
                    const pastMonthData = monthlySimulationResults[i];
                    if (i < actualPurchaseMonths && pastMonthData.purchaseDate && pastMonthData.actualPayoutMetStatus === null) {
                        const payoutDateForPastPurchase = addDays(pastMonthData.purchaseDate, PAYOUT_DELAY_DAYS);
                        const payoutMonthEndDateForPastPurchase = getEndOfMonthLocal(payoutDateForPastPurchase);

                        if (payoutMonthEndDateForPastPurchase.getTime() <= currentSimMonthEnd.getTime()) {
                            const owedFromPastFull = pastMonthData.cashbackAccruedThisMonth;
                            const netCashbackToCoverByTradingFund = Math.max(0, owedFromPastFull - (monthlyMarkupAmounts[pastMonthData.month -1] * (1 - markupAllocationToTradingFund))); // Use markup from original purchase month
                            
                            const deductionForMonthlyTable = netCashbackToCoverByTradingFund;
                            monthData.payoutDeductedInThisMonth += deductionForMonthlyTable;
                            pastMonthData.actualDeductionForThisPurchaseMonth = deductionForMonthlyTable;
                        }
                    }
                }
                monthData.endingTradingCapital = fundAfterTrades;
                currentTradingFundAtStartOfMonth = monthData.endingTradingCapital;

                monthlySimulationResults.push(monthData);

                if (monthIndex < actualPurchaseMonths) {
                    const purchaseDateForDisplay = new Date(initialDate.getFullYear(), initialDate.getMonth() + monthIndex, initialDate.getDate());
                    purchaseDateForDisplay.setHours(0, 0, 0, 0); // Normalize to local midnight
                    monthData.cashbackDueDate = addDays(purchaseDateForDisplay, PAYOUT_DELAY_DAYS);
                    monthData.payoutMonthEnd = getEndOfMonthLocal(monthData.cashbackDueDate);

                    monthlyPurchaseData.push(monthData);
                }
            }

            const finalNetFundPerformance = runCumulativeDailySimulation(_monthlyMarkupForReserve); // Pass monthly markup for reserve

            let totalCashbackPaid = 0;
            let overallPayoutSuccess = true;
            monthlyPurchaseData.forEach(data => {
                totalCashbackPaid += data.actualDeductionForThisPurchaseMonth;
                if (data.actualPayoutMetStatus === false) {
                    overallPayoutSuccess = false;
                }
            });

            updateCombinedPayoutTable(monthlyPurchaseData);
            updateSummary(cumulativeVoucherPurchases, totalCashbackOwedAccrued, totalCashbackPaid, finalNetFundPerformance, overallPayoutSuccess);
        };

        /**
         * Updates the combined Net Payout Obligation and Fund Balance After Payout table.
         * @param {Array<Object>} results - The array of monthly simulation data (actual purchase months).
         */
        const updateCombinedPayoutTable = (results) => {
            combinedPayoutTableBody.innerHTML = '';

            results.forEach(data => {
                let fundBalanceDisplay;
                let fundBalanceClass;
                let payoutMetDisplay;
                let payoutMetClass;
                let payoutDeductedDisplay;
                let payoutDeductedClass;

                if (data.actualPayoutSurplusDeficit !== null) {
                    fundBalanceDisplay = formatCurrency(data.actualPayoutSurplusDeficit);
                    fundBalanceClass = data.actualPayoutSurplusDeficit >= 0 ? 'text-green-600' : 'text-red-600';
                } else {
                    console.warn(`Payout for Month ${data.month} was not fully processed by daily sim. actualPayoutSurplusDeficit is null.`);
                    fundBalanceDisplay = 'N/A';
                    fundBalanceClass = 'text-gray-500';
                }

                if (data.actualPayoutMetStatus !== null) {
                    payoutMetDisplay = data.actualPayoutMetStatus ? 'Met' : 'Shortfall';
                    payoutMetClass = data.actualPayoutMetStatus ? 'text-green-600' : 'text-red-600';
                } else {
                    console.warn(`Payout for Month ${data.month} was not fully processed by daily sim. actualPayoutMetStatus is null.`);
                    payoutMetDisplay = 'N/A';
                    payoutMetClass = 'text-gray-500';
                }

                if (data.actualDeductionForThisPurchaseMonth !== undefined) {
                    payoutDeductedDisplay = formatCurrency(data.actualDeductionForThisPurchaseMonth);
                    payoutDeductedClass = data.actualDeductionForThisPurchaseMonth > 0 ? 'text-red-600' : 'text-gray-600';
                } else {
                    payoutDeductedDisplay = 'N/A';
                    payoutDeductedClass = 'text-gray-500';
                }

                const row = `
                    <tr>
                        <td class="px-6 py-4 whitespace-nowrap">${data.month}</td>
                        <td class="px-6 py-4 whitespace-nowrap">${data.purchaseDate.toLocaleDateString('en-JM', { day: 'numeric', month: 'short', year: 'numeric' })}</td>
                        <td class="px-6 py-4 whitespace-nowrap">${formatCurrency(data.monthlyFundContribution)}</td>
                        <td class="px-6 py-4 whitespace-nowrap">${data.cashbackDueDate.toLocaleDateString('en-JM', { day: 'numeric', month: 'short', year: 'numeric' })}</td>
                        <td class="px-6 py-4 whitespace-nowrap">${data.payoutMonthEnd.toLocaleDateString('en-JM', { day: 'numeric', month: 'short', year: 'numeric' })}</td>
                        <td class="px-6 py-4 whitespace-nowrap">${formatCurrency(data.accruedNetPayoutObligation)}</td>
                        <td class="px-6 py-4 whitespace-nowrap ${payoutDeductedClass}">${payoutDeductedDisplay}</td>
                        <td class="px-6 py-4 whitespace-nowrap ${fundBalanceClass}">${fundBalanceDisplay}</td>
                        <td class="px-6 py-4 whitespace-nowrap">
                            <span class="${payoutMetClass}">
                                ${payoutMetDisplay}
                            </span>
                        </td>
                    </tr>
                `;
                combinedPayoutTableBody.insertAdjacentHTML('beforeend', row);
            });
        };

        /**
         * Updates the summary section.
         * @param {number} cumulativeVoucherPurchases - Total voucher purchases.
         * @param {number} totalCashbackOwedAccrued - Total cashback accrued.
         * @param {number} totalCashbackPaid - Total cashback actually paid out.
         * @param {number} finalTradingFund - The trading fund at the end of the simulation.
         * @param {boolean} overallPayoutSuccess - Whether all payouts were met.
         */
        const updateSummary = (cumulativeVoucherPurchases, totalCashbackOwedAccrued, totalCashbackPaid, finalTradingFund, overallPayoutSuccess) => {
            cumulativeVoucherPurchasesSpan.textContent = formatCurrency(cumulativeVoucherPurchases);
            totalCashbackOwedAccruedSpan.textContent = formatCurrency(totalCashbackOwedAccrued);
            totalCashbackPaidSpan.textContent = formatCurrency(totalCashbackPaid);
            netFundPerformanceSpan.textContent = formatCurrency(finalTradingFund);
            netFundPerformanceSpan.classList.toggle('text-green-600', finalTradingFund >= 0);
            netFundPerformanceSpan.classList.toggle('text-red-600', finalTradingFund < 0);

            if (overallPayoutSuccess) {
                overallPayoutStatusSpan.textContent = 'All Payouts Met';
                overallPayoutStatusSpan.className = 'font-bold text-green-600';
            } else {
                overallPayoutStatusSpan.textContent = 'Payout Shortfall Occurred';
                overallPayoutStatusSpan.className = 'font-bold text-red-600';
            }
        };

        // --- Cumulative Daily Simulation Logic ---

        /**
         * Runs the cumulative daily simulation for the entire period, enforcing max 2 trades per week.
         * This function also updates the `actualPayoutSurplusDeficit` and `actualPayoutMetStatus`
         * for each relevant monthly purchase data object based on the daily fund balance.
         * It also calculates the daily Reserve Flow.
         * @param {Array<number>} monthlyMarkupForReserve - Monthly markup amounts allocated to the reserve.
         * @returns {number} The final capital after all daily events.
         */
        const runCumulativeDailySimulation = (monthlyMarkupForReserve) => {
            dailyLogTableBody.innerHTML = '';
            dailyReserveFlowLog = []; // Clear previous daily reserve log

            const actualPurchaseMonths = parseInt(numberOfPurchaseMonthsInput.value);
            const validPurchaseMonths = isNaN(actualPurchaseMonths) || actualPurchaseMonths < 1 ? 1 : actualPurchaseMonths;


            const startDate = new Date(simulationStartDateInput.value);
            startDate.setHours(0, 0, 0, 0);

            // Determine the true end date for the daily log, covering all purchase months + payout delay
            let tempEndDate = new Date(startDate);
            tempEndDate.setMonth(tempEndDate.getMonth() + validPurchaseMonths -1);
            tempEndDate = getEndOfMonthLocal(addDays(tempEndDate, PAYOUT_DELAY_DAYS)); // End of month of last payout
            
            const endDate = tempEndDate; // Use this calculated end date

            let currentDailyCapital = parseFloat(initialTradingFundInput.value);
            let currentDailyReserve = 0; // Start at 0 as per user request
            let cumulativeAccruedCashbackLiability = 0; // Start at 0 as per user request

            const avgWeeklyWin = parseFloat(avgWeeklyWinInput.value) / 100;
            const maxWeeklyLoss = parseFloat(maxWeeklyLossInput.value) / 100;
            const winRate = parseFloat(winRateInput.value);

            const totalDaysInPeriod = Math.ceil((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24)) + 1;
            const totalWeeksInPeriod = Math.ceil(totalDaysInPeriod / 7);
            const maxPossibleTrades = totalWeeksInPeriod * MAX_TRADES_PER_WEEK;

            const seedValue = parseInt(simulationSeedInput.value);
            const dailyRng = new SeededRandom(isNaN(seedValue) || simulationSeedInput.value === '' ? Date.now() : seedValue);
            const tradeOutcomes = generateTradeOutcomes(maxPossibleTrades, winRate, dailyRng);

            let dayCounter = 1;
            let currentDate = new Date(startDate);

            let tradesThisWeek = 0;

            const monthlyContributionsMap = new Map();
            const monthlyPayoutsMap = new Map();
            const dailyMarkupAdditionsMap = new Map(); // Map for daily markup additions to reserve
            const dailyLiabilityAdditionsMap = new Map(); // Map for daily liability additions

            const selectedTier = membershipTierInput.value;
            const tierConfig = MEMBERSHIP_TIERS[selectedTier];
            const markupRate = parseFloat(markupRateInput.value) / 100;
            const markupAllocationToTradingFund = parseFloat(markupAllocationToTradingFundInput.value) / 100;
            const membershipAllocationToTradingFund = 0.50;
            const oneTimeMembershipFundAddition = tierConfig.fee * membershipAllocationToTradingFund;

            // Collect monthly contributions and payouts from the main simulation's calculated data
            monthlyPurchaseData.forEach((data, index) => {
                const purchaseDate = data.purchaseDate;
                if (purchaseDate) {
                    const monthKey = purchaseDate.toLocaleDateString('en-CA', { year: 'numeric', month: '2-digit', day: '2-digit' });
                    monthlyContributionsMap.set(monthKey, data.monthlyFundContribution);
                }

                const payoutDate = data.payoutMonthEnd;
                if (payoutDate) {
                    const payoutDateString = payoutDate.toLocaleDateString('en-CA', { year: 'numeric', month: '2-digit', day: '2-digit' });
                    const payoutInfo = {
                        monthlyDataRef: data,
                        netObligation: data.accruedNetPayoutObligation,
                        actualDeduction: data.actualDeductionForThisPurchaseMonth
                    };
                    // Group payouts by date, as multiple purchase months might have payouts due on the same day
                    if (monthlyPayoutsMap.has(payoutDateString)) {
                        monthlyPayoutsMap.get(payoutDateString).push(payoutInfo);
                    } else {
                        monthlyPayoutsMap.set(payoutDateString, [payoutInfo]);
                    }
                }
            });

            // Pre-process monthly markup and liability to daily event maps
            const rfVoucherDefinitions = getRfVoucherDefinitions();
            const mainSimMonthlySales = Array.from({ length: validPurchaseMonths }, () => ({ '10k': 0, '15k': 0, '20k': 0 }));
            document.querySelectorAll('#mainSimulationMonthlySalesInputTable .main-sim-sales-input').forEach(input => {
                const voucherType = input.dataset.voucher;
                const monthIndex = parseInt(input.dataset.month);
                if (monthIndex < validPurchaseMonths) {
                    mainSimMonthlySales[monthIndex][voucherType] = parseInt(input.value) || 0;
                }
            });

            for (let i = 0; i < validPurchaseMonths; i++) {
                const sales = mainSimMonthlySales[i] || { '10k': 0, '15k': 0, '20k': 0 };
                const cashback10k = rfVoucherDefinitions['J$10K Voucher'].cashback;
                const cashback15k = rfVoucherDefinitions['J$15K Voucher'].cashback;
                const cashback20k = rfVoucherDefinitions['J$20K Voucher'].cashback;
                const grossCashbackOwedThisMonth = (sales['10k'] * cashback10k + sales['15k'] * cashback15k + sales['20k'] * cashback20k);

                const markupForThisMonth = monthlyMarkupForReserve[i];

                let applicationDate;
                if (i === 0) {
                    applicationDate = new Date(startDate); // First month's sales apply on sim start date
                } else {
                    applicationDate = new Date(startDate.getFullYear(), startDate.getMonth() + i, 1); // Subsequent months apply on 1st
                }
                applicationDate.setHours(0, 0, 0, 0); // Normalize to local midnight

                if (markupForThisMonth > 0) {
                    const dateKey = applicationDate.toLocaleDateString('en-CA', { year: 'numeric', month: '2-digit', day: '2-digit' });
                    dailyMarkupAdditionsMap.set(dateKey, (dailyMarkupAdditionsMap.get(dateKey) || 0) + markupForThisMonth);
                }
                if (grossCashbackOwedThisMonth > 0) {
                    const dateKey = applicationDate.toLocaleDateString('en-CA', { year: 'numeric', month: '2-digit', day: '2-digit' });
                    dailyLiabilityAdditionsMap.set(dateKey, (dailyLiabilityAdditionsMap.get(dateKey) || 0) + grossCashbackOwedThisMonth);
                }
            }

            // Create a set of all specific payout month-end dates for quick lookup
            const specificPayoutMonthEnds = new Set();
            monthlyPurchaseData.forEach(data => {
                if (data.payoutMonthEnd) {
                    specificPayoutMonthEnds.add(data.payoutMonthEnd.toLocaleDateString('en-CA', { year: 'numeric', month: '2-digit', day: '2-digit' }));
                }
            });


            while (currentDate <= endDate) {
                const currentDateString = currentDate.toLocaleDateString('en-CA', { year: 'numeric', month: '2-digit', day: '2-digit' });
                const dayOfWeek = currentDate.getDay(); // 0 = Sunday, 1 = Monday, ..., 6 = Saturday
                const isWeekday = (dayOfWeek >= 1 && dayOfWeek <= 5);

                // Check if it's a specific payout month-end date
                const isSpecificPayoutMonthEndDate = specificPayoutMonthEnds.has(currentDateString);


                if (dayOfWeek === 1 || dayCounter === 1) {
                    tradesThisWeek = 0;
                }

                let eventOccurred = false;
                let eventType = 'No Event';
                let dailyNetChange = 0;

                let capitalBeforeEvent = currentDailyCapital;
                let reserveStartOfDay = currentDailyReserve; // Reserve balance at start of day for this row
                let liabilityStartOfDay = cumulativeAccruedCashbackLiability; // Liability balance at start of day for this row

                let dailyReserveAdd = 0;
                let dailyReservePayout = 0; // This will store the absolute value of the payout for display
                let dailyLiabilityAccrual = 0; // Renamed for clarity, this is the daily amount of new liability incurred

                // Trading Fund Contribution (from markup allocation to trading fund)
                const contributionForToday = monthlyContributionsMap.get(currentDateString);
                if (contributionForToday) {
                    currentDailyCapital += contributionForToday;
                    dailyNetChange += contributionForToday;
                    eventOccurred = true;
                    eventType = 'Contribution';
                }

                // Apply Add Reserve (+ Markup)
                const markupToAdd = dailyMarkupAdditionsMap.get(currentDateString); // Use consistent date string
                if (markupToAdd !== undefined && markupToAdd > 0) {
                    currentDailyReserve += markupToAdd;
                    dailyReserveAdd = markupToAdd;
                    if (eventType === 'No Event') eventType = 'Reserve Add (Markup)';
                    else eventType += ' & Reserve Add (Markup)';
                }

                // Apply new Liability accrual
                const liabilityToAdd = dailyLiabilityAdditionsMap.get(currentDateString); // Use consistent date string
                if (liabilityToAdd !== undefined && liabilityToAdd > 0) {
                    cumulativeAccruedCashbackLiability += liabilityToAdd;
                    dailyLiabilityAccrual = liabilityToAdd; // Track for internal use
                }


                // Payouts Due Today (for both Trading Fund and Reserve Fund)
                const payoutsDueToday = monthlyPayoutsMap.get(currentDateString);
                const isPayoutDay = payoutsDueToday && payoutsDueToday.length > 0;

                if (isPayoutDay) {
                    let totalPaidThisDay = 0;
                    payoutsDueToday.forEach(payout => {
                        const amountToPay = payout.actualDeduction;
                        if (currentDailyCapital >= amountToPay) { // Check if trading fund can cover this specific payout
                            currentDailyCapital -= amountToPay;
                            dailyNetChange -= amountToPay; // Net change reflects actual deduction
                            currentDailyReserve -= amountToPay; // Actual deduction from reserve
                            totalPaidThisDay += amountToPay; // Accumulate amount actually paid for this day
                            cumulativeAccruedCashbackLiability -= amountToPay; // Only reduce liability if paid
                            payout.monthlyDataRef.actualPayoutMetStatus = true; // Mark as met for this specific payout
                        } else {
                            // Trading fund cannot cover this payout.
                            // The liability remains. The reserve is not reduced by this amount.
                            payout.monthlyDataRef.actualPayoutMetStatus = false; // Mark as not met
                            // No change to currentDailyCapital for this specific payout, as it couldn't be made.
                            // No change to currentDailyReserve for this specific payout.
                            // No reduction in cumulativeAccruedCashbackLiability for this specific payout.
                            // We still need to reflect the negative capital in the trading log.
                        }
                        // Update the monthly data's surplus/deficit based on the trading fund's state
                        payout.monthlyDataRef.actualPayoutSurplusDeficit = currentDailyCapital;
                    });
                    dailyReservePayout = totalPaidThisDay; // Set dailyReservePayout to the total amount actually paid
                    eventOccurred = true;
                    if (eventType === 'No Event') eventType = 'Cashback Payout';
                    else eventType += ' & Payout';
                }
                // Ensure cumulativeAccruedCashbackLiability doesn't go below zero
                cumulativeAccruedCashbackLiability = Math.max(0, cumulativeAccruedCashbackLiability);

                let isTradingDayForDisplay = false;
                const canTradeOnThisDay = isWeekday && !contributionForToday && !isPayoutDay && tradesThisWeek < MAX_TRADES_PER_WEEK && currentDailyCapital > 0;

                if (canTradeOnThisDay && tradeOutcomes.length > 0) {
                    const isWin = tradeOutcomes.shift();
                    const capitalForTradeCalculation = currentDailyCapital;

                    let tradeGainLossAmount;
                    if (isWin) {
                        tradeGainLossAmount = capitalForTradeCalculation * avgWeeklyWin;
                        if (eventType === 'No Event') eventType = 'Trade (Win)';
                        else eventType += ' & Trade (Win)';
                    } else {
                        tradeGainLossAmount = -capitalForTradeCalculation * maxWeeklyLoss;
                        if (eventType === 'No Event') eventType = 'Trade (Loss)';
                        else eventType += ' & Trade (Loss)';
                    }
                    currentDailyCapital += tradeGainLossAmount;
                    dailyNetChange += tradeGainLossAmount;
                    eventOccurred = true;
                    tradesThisWeek++;
                    isTradingDayForDisplay = true;
                }

                // Calculate Net Reserve Coverage using the *current* (updated) cumulative values
                // These are the true running balances
                const netReserveCoverageActual = currentDailyReserve - cumulativeAccruedCashbackLiability;
                const statusActual = netReserveCoverageActual >= 0 ? 'POSITIVE' : 'NEGATIVE';

                // Record daily Reserve Flow
                dailyReserveFlowLog.push({
                    day: dayCounter,
                    date: new Date(currentDate),
                    reserveStart: reserveStartOfDay, // Reserve at start of day
                    addReserve: dailyReserveAdd, // Markup added
                    payCashback: dailyReservePayout, // Actual amount paid out from reserve
                    
                    // Display values for Total Reserve and Total Owed Liability on payout dates
                    // These will now be the actual end-of-day balances
                    totalReserveEndOfDay: currentDailyReserve, // Actual reserve balance after all daily events
                    totalOwedLiabilityEndOfDay: cumulativeAccruedCashbackLiability, // Actual outstanding liability after all daily events

                    // Net Reserve Coverage and Status will always reflect the true current state
                    netReserveCoverage: netReserveCoverageActual,
                    status: statusActual,

                    isPayoutDateForDisplay: isSpecificPayoutMonthEndDate // Flag for conditional display
                });


                // RESTORED: Cumulative Daily Trading Log row generation
                const tradingLog_row = `
                    <tr>
                        <td class="px-6 py-4 whitespace-nowrap">${dayCounter}</td>
                        <td class="px-6 py-4 whitespace-nowrap">${currentDate.toLocaleDateString('en-JM', { month: 'short', day: 'numeric', year: 'numeric' })}</td>
                        <td class="px-6 py-4 whitespace-nowrap">${currentDate.toLocaleDateString('en-JM', { weekday: 'short' })}</td>
                        <td class="px-6 py-4 whitespace-nowrap">
                            ${isTradingDayForDisplay ? 'Yes' : 'No'}
                        </td>
                        <td class="px-6 py-4 whitespace-nowrap">
                            ${eventOccurred ? 'Yes' : 'No'}
                        </td>
                        <td class="px-6 py-4 whitespace-nowrap">
                            <span class="${eventType.includes('Win') ? 'text-green-600' : (eventType.includes('Loss') || eventType.includes('Payout') ? 'text-red-600' : 'text-gray-500')}">
                                ${eventType}
                            </span>
                        </td>
                        <td class="px-6 py-4 whitespace-nowrap ${dailyNetChange >= 0 ? 'text-green-600' : 'text-red-600'}">${formatCurrency(dailyNetChange)}</td>
                        <td class="px-6 py-4 whitespace-nowrap">${formatCurrency(capitalBeforeEvent)}</td>
                        <td class="px-6 py-4 whitespace-nowrap">${formatCurrency(currentDailyCapital)}</td>
                    </tr>
                `;
                dailyLogTableBody.insertAdjacentHTML('beforeend', tradingLog_row);

                currentDate.setDate(currentDate.getDate() + 1);
                dayCounter++;
            }
            console.log("dailyReserveFlowLog after daily simulation:", dailyReserveFlowLog); // Debug log
            return currentDailyCapital;
        };

        function updateInitialTradingFundDefault() {
            const currentInputValue = parseFloat(initialTradingFundInput.value);
            if (isNaN(currentInputValue) || currentInputValue === 0) {
                initialTradingFundInput.value = '0';
            }
        }

        // --- Event Listeners and Initial Setup (Existing Simulation) ---

        // Update main simulation inputs and re-run both simulations when # Of Months changes
        numberOfPurchaseMonthsInput.addEventListener('input', () => {
            initializeMainSimulationInputs(); // Re-initialize main simulation sales inputs
            initializeReserveFlowInputs(); // Re-initialize reserve flow inputs to match new month count
            runSimulation();
            runReserveFlowSimulation();
        });

        // Other main simulation inputs
        membershipTierInput.addEventListener('change', () => {
            runSimulation();
            runReserveFlowSimulation(); // Also update reserve flow when tier changes
        });
        simulationStartDateInput.addEventListener('change', runSimulation);
        markupRateInput.addEventListener('input', () => {
            runSimulation();
            runReserveFlowSimulation(); // Also update reserve flow when markup rate changes
        });
        markupAllocationToTradingFundInput.addEventListener('input', runSimulation);
        initialTradingFundInput.addEventListener('input', runSimulation);
        avgWeeklyWinInput.addEventListener('input', runSimulation);
        maxWeeklyLossInput.addEventListener('input', runSimulation);
        winRateInput.addEventListener('input', runSimulation);
        simulationSeedInput.addEventListener('input', runSimulation);
        stressTestModeCheckbox.addEventListener('change', runSimulation);

        // Function to initialize main simulation monthly sales input fields
        const initializeMainSimulationInputs = () => {
            const numMonths = parseInt(numberOfPurchaseMonthsInput.value);
            if (isNaN(numMonths) || numMonths < 1) return;

            // Clear existing headers and inputs
            mainSimulationMonthlySalesInputHeader.innerHTML = '<th class="px-6 py-3">Voucher Type</th>';
            mainSimulation10kVoucherRow.innerHTML = '<td class="px-6 py-4 whitespace-nowrap">J$10K Voucher</td>';
            mainSimulation15kVoucherRow.innerHTML = '<td class="px-6 py-4 whitespace-nowrap">J$15K Voucher</td>';
            mainSimulation20kVoucherRow.innerHTML = '<td class="px-6 py-4 whitespace-nowrap">J$20K Voucher</td>';

            for (let i = 0; i < numMonths; i++) {
                const monthName = `Month ${i + 1}`;
                mainSimulationMonthlySalesInputHeader.insertAdjacentHTML('beforeend', `<th class="px-6 py-3">${monthName}</th>`);

                mainSimulation10kVoucherRow.insertAdjacentHTML('beforeend', `<td class="px-6 py-4 whitespace-nowrap"><input type="number" class="w-full p-2 border rounded main-sim-sales-input" data-voucher="10k" data-month="${i}" value="0" min="0"></td>`);
                mainSimulation15kVoucherRow.insertAdjacentHTML('beforeend', `<td class="px-6 py-4 whitespace-nowrap"><input type="number" class="w-full p-2 border rounded main-sim-sales-input" data-voucher="15k" data-month="${i}" value="0" min="0"></td>`);
                mainSimulation20kVoucherRow.insertAdjacentHTML('beforeend', `<td class="px-6 py-4 whitespace-nowrap"><input type="number" class="w-full p-2 border rounded main-sim-sales-input" data-voucher="20k" data-month="${i}" value="0" min="0"></td>`);
            }

            // Add event listeners to new input fields
            document.querySelectorAll('.main-sim-sales-input').forEach(input => {
                input.addEventListener('input', () => {
                    runSimulation();
                    runReserveFlowSimulation(); // Also update reserve flow when main sim sales change
                });
            });
        };


        document.addEventListener('DOMContentLoaded', () => {
            const today = new Date();
            today.setHours(0, 0, 0, 0); // Normalize to local midnight
            const year = today.getFullYear();
            const month = (today.getMonth() + 1).toString().padStart(2, '0');
            const day = today.getDate().toString().padStart(2, '0');
            simulationStartDateInput.value = `${year}-${month}-${day}`;

            updateInitialTradingFundDefault();
            initializeMainSimulationInputs(); // Initialize main simulation sales inputs first
            runSimulation();
            initializeReserveFlowInputs(); // Initialize reserve flow inputs
            runReserveFlowSimulation(); // Run the new simulation on load
        });


        // --- NEW SECTION: Reserve Flow Calculator Logic ---

        // Constants for Reserve Flow Calculator
        const RF_PAYOUT_DELAY_MONTHS = 4; // Approx 121 days / 30.4375 days/month

        const RF_MARKUP_ALLOCATION_TO_RESERVE = 0.83; // 1 - 0.17 from Google Script (Markup allocated to reserve)

        // DOM Elements for Reserve Flow Calculator
        const rfVoucherDefinitionsTableBody = document.getElementById('rfVoucherDefinitionsTableBody'); // New tbody ID
        const rfMonthlySalesInputHeader = document.getElementById('rfMonthlySalesInputHeader');
        const rf10kVoucherRow = document.getElementById('rf10kVoucherRow');
        const rf15kVoucherRow = document.getElementById('rf15kVoucherRow');
        const rf20kVoucherRow = document.getElementById('rf20kVoucherRow');
        const rfMonthlyFinancialsHeader = document.getElementById('rfMonthlyFinancialsHeader');
        const rfTotalGrossMarkupRow = document.getElementById('rfTotalGrossMarkupRow'); // New row for gross markup
        const rfAllocatedMarkupAddedRow = document.getElementById('rfAllocatedMarkupAddedRow'); // Renamed
        const rfTotalCashbackOwedRow = document.getElementById('rfTotalCashbackOwedRow');
        const rfActualCashbackPaidOutRow = document.getElementById('rfActualCashbackPaidOutRow');
        const rfReserveFlowTableBody = document.querySelector('#rfReserveFlowTable tbody');

        // Function to dynamically get voucher definitions based on current inputs
        const getRfVoucherDefinitions = () => {
            const currentMarkupRate = parseFloat(markupRateInput.value) / 100;
            const selectedTier = membershipTierInput.value;
            const tierConfig = MEMBERSHIP_TIERS[selectedTier];

            return {
                'J$10K Voucher': {
                    value: 10000,
                    markup: 10000 * currentMarkupRate,
                    cashback: 10000 * tierConfig.cashbackRates[10000]
                },
                'J$15K Voucher': {
                    value: 15000,
                    markup: 15000 * currentMarkupRate,
                    cashback: 15000 * tierConfig.cashbackRates[15000]
                },
                'J$20K Voucher': {
                    value: 20000,
                    markup: 20000 * currentMarkupRate,
                    cashback: 20000 * tierConfig.cashbackRates[20000]
                }
            };
        };

        // Function to update the RF Voucher Definitions table
        const updateRfVoucherDefinitionsTable = () => {
            const rfVoucherDefinitions = getRfVoucherDefinitions();
            rfVoucherDefinitionsTableBody.innerHTML = `
                <tr>
                    <td class="px-6 py-4 whitespace-nowrap">J$10K Voucher</td>
                    <td class="px-6 py-4 whitespace-nowrap">${formatCurrency(rfVoucherDefinitions['J$10K Voucher'].markup)}</td>
                    <td class="px-6 py-4 whitespace-nowrap">${formatCurrency(rfVoucherDefinitions['J$10K Voucher'].cashback)}</td>
                </tr>
                <tr>
                    <td class="px-6 py-4 whitespace-nowrap">J$15K Voucher</td>
                    <td class="px-6 py-4 whitespace-nowrap">${formatCurrency(rfVoucherDefinitions['J$15K Voucher'].markup)}</td>
                    <td class="px-6 py-4 whitespace-nowrap">${formatCurrency(rfVoucherDefinitions['J$15K Voucher'].cashback)}</td>
                </tr>
                <tr>
                    <td class="px-6 py-4 whitespace-nowrap">J$20K Voucher</td>
                    <td class="px-6 py-4 whitespace-nowrap">${formatCurrency(rfVoucherDefinitions['J$20K Voucher'].markup)}</td>
                    <td class="px-6 py-4 whitespace-nowrap">${formatCurrency(rfVoucherDefinitions['J$20K Voucher'].cashback)}</td>
                </tr>
            `;
        };

        // Function to generate month headers and display cells dynamically for Reserve Flow Sales Input
        const initializeReserveFlowInputs = () => {
            const numMonthsInMainSimulation = parseInt(numberOfPurchaseMonthsInput.value);
            const totalMonthsForRfDisplay = Math.min(60, numMonthsInMainSimulation + EXTRA_MONTHS_FOR_PAYOUTS); // Cap at 60 months for display

            // Clear existing headers and rows
            rfMonthlySalesInputHeader.innerHTML = '<th class="px-6 py-3">Voucher Type</th>';
            rf10kVoucherRow.innerHTML = '<td class="px-6 py-4 whitespace-nowrap">J$10K Voucher</td>';
            rf15kVoucherRow.innerHTML = '<td class="px-6 py-4 whitespace-nowrap">J$15K Voucher</td>';
            rf20kVoucherRow.innerHTML = '<td class="px-6 py-4 whitespace-nowrap">J$20K Voucher</td>';

            rfMonthlyFinancialsHeader.innerHTML = '<th class="px-6 py-3">Financial Metric</th>';
            rfTotalGrossMarkupRow.innerHTML = '<td class="px-6 py-4 whitespace-nowrap">Gross Markup from Sales (J$)</td>'; // New row
            rfAllocatedMarkupAddedRow.innerHTML = '<td class="px-6 py-4 whitespace-nowrap">Allocated Markup Added to Reserve (J$)</td>'; // Renamed
            rfTotalCashbackOwedRow.innerHTML = '<td class="px-6 py-4 whitespace-nowrap">Total Cashback Owed (J$) (Liability Incurred)</td>';
            rfActualCashbackPaidOutRow.innerHTML = '<td class="px-6 py-4 whitespace-nowrap">Actual Cashback Paid Out (J$) (121-day delay)</td>';


            for (let i = 0; i < totalMonthsForRfDisplay; i++) {
                const monthName = `Month ${i + 1}`;
                // Add month headers
                rfMonthlySalesInputHeader.insertAdjacentHTML('beforeend', `<th class="px-6 py-3">${monthName}</th>`);
                rfMonthlyFinancialsHeader.insertAdjacentHTML('beforeend', `<th class="px-6 py-3">${monthName}</th>`);

                // Add empty cells for each voucher type, to be filled by runReserveFlowSimulation
                rf10kVoucherRow.insertAdjacentHTML('beforeend', `<td class="px-6 py-4 whitespace-nowrap" id="rf-10k-month-${i}"></td>`);
                rf15kVoucherRow.insertAdjacentHTML('beforeend', `<td class="px-6 py-4 whitespace-nowrap" id="rf-15k-month-${i}"></td>`);
                rf20kVoucherRow.insertAdjacentHTML('beforeend', `<td class="px-6 py-4 whitespace-nowrap" id="rf-20k-month-${i}"></td>`);
            }

            // Call this function to update the calculated voucher definitions table
            updateRfVoucherDefinitionsTable();
        };

        /**
         * Runs the Reserve Flow simulation.
         */
        const runReserveFlowSimulation = () => {
            rfReserveFlowTableBody.innerHTML = ''; // Clear previous results

            const rfVoucherDefinitions = getRfVoucherDefinitions(); // Get dynamic definitions

            // Update the Voucher Type Definitions table (ensure this is called here)
            updateRfVoucherDefinitionsTable();

            const numMonthsInMainSimulation = parseInt(numberOfPurchaseMonthsInput.value);
            const totalMonthsForRfCalculation = numMonthsInMainSimulation + EXTRA_MONTHS_FOR_PAYOUTS;

            // Get monthly sales inputs from the MAIN simulation table
            const monthlySales = Array.from({ length: totalMonthsForRfCalculation }, () => ({ '10k': 0, '15k': 0, '20k': 0 }));

            document.querySelectorAll('#mainSimulationMonthlySalesInputTable .main-sim-sales-input').forEach(input => {
                const voucherType = input.dataset.voucher;
                const monthIndex = parseInt(input.dataset.month);
                if (monthIndex < numMonthsInMainSimulation) {
                    monthlySales[monthIndex][voucherType] = parseInt(input.value) || 0;
                }
            });

            // Populate the Reserve Flow's Monthly Sales Input table with values from main simulation
            const totalMonthsForRfDisplay = Math.min(60, totalMonthsForRfCalculation);

            for (let i = 0; i < totalMonthsForRfDisplay; i++) {
                const sales10k = (i < numMonthsInMainSimulation) ? monthlySales[i]['10k'] : 0;
                const sales15k = (i < numMonthsInMainSimulation) ? monthlySales[i]['15k'] : 0;
                const sales20k = (i < numMonthsInMainSimulation) ? monthlySales[i]['20k'] : 0;

                const elem10k = document.getElementById(`rf-10k-month-${i}`);
                if (elem10k) elem10k.textContent = sales10k;
                
                const elem15k = document.getElementById(`rf-15k-month-${i}`);
                if (elem15k) elem15k.textContent = sales15k;

                const elem20k = document.getElementById(`rf-20k-month-${i}`);
                if (elem20k) elem20k.textContent = sales20k;
            }

            const totalGrossMarkupMonthly = Array(totalMonthsForRfCalculation).fill(0); // New array for gross markup
            // totalMarkupAddedMonthly will now directly use _monthlyMarkupForReserve
            const totalCashbackOwedMonthly = Array(totalMonthsForRfCalculation).fill(0); // This is liability
            const actualCashbackPaidOutMonthly = Array(totalMonthsForRfCalculation).fill(0); // This is from dailyReserveFlowLog

            // Calculate Total Gross Markup and Total Cashback Owed (Liability) monthly
            for (let i = 0; i < totalMonthsForRfCalculation; i++) {
                const sales = monthlySales[i];
                const markup10k = rfVoucherDefinitions['J$10K Voucher'].markup;
                const markup15k = rfVoucherDefinitions['J$15K Voucher'].markup;
                const markup20k = rfVoucherDefinitions['J$20K Voucher'].markup;

                const cashback10k = rfVoucherDefinitions['J$10K Voucher'].cashback;
                const cashback15k = rfVoucherDefinitions['J$15K Voucher'].cashback;
                const cashback20k = rfVoucherDefinitions['J$20K Voucher'].cashback;

                // Gross Markup
                totalGrossMarkupMonthly[i] = (sales['10k'] * markup10k + sales['15k'] * markup15k + sales['20k'] * markup20k);

                // Total Cashback Owed (Liability Incurred)
                totalCashbackOwedMonthly[i] = (sales['10k'] * cashback10k + sales['15k'] * cashback15k + sales['20k'] * cashback20k);
            }

            // Aggregate data from dailyReserveFlowLog for actualCashbackPaidOutMonthly
            const simStartDate = new Date(simulationStartDateInput.value);
            simStartDate.setHours(0, 0, 0, 0);

            dailyReserveFlowLog.forEach(dailyEntry => {
                const date = dailyEntry.date;
                const monthDiff = (date.getFullYear() - simStartDate.getFullYear()) * 12 +
                                 (date.getMonth() - simStartDate.getMonth());

                if (monthDiff >= 0 && monthDiff < totalMonthsForRfCalculation) {
                    actualCashbackPaidOutMonthly[monthDiff] += dailyEntry.payCashback; // payCashback is stored as positive
                }
            });

            // Populate Monthly Financials Table
            for (let i = 0; i < totalMonthsForRfDisplay; i++) {
                const grossMarkupCell = document.querySelector(`#rfTotalGrossMarkupRow td:nth-child(${i + 2})`);
                if (grossMarkupCell) grossMarkupCell.textContent = formatCurrency(totalGrossMarkupMonthly[i]);

                const allocatedMarkupCell = document.querySelector(`#rfAllocatedMarkupAddedRow td:nth-child(${i + 2})`);
                if (allocatedMarkupCell) allocatedMarkupCell.textContent = formatCurrency(_monthlyMarkupForReserve[i] || 0); // Use _monthlyMarkupForReserve

                const cashbackOwedCell = document.querySelector(`#rfTotalCashbackOwedRow td:nth-child(${i + 2})`);
                if (cashbackOwedCell) cashbackOwedCell.textContent = formatCurrency(totalCashbackOwedMonthly[i]);

                const cashbackPaidCell = document.querySelector(`#rfActualCashbackPaidOutRow td:nth-child(${i + 2})`);
                if (cashbackPaidCell) cashbackPaidOutCell.textContent = formatCurrency(actualCashbackPaidOutMonthly[i]);
            }

            console.log("Populating RF Reserve Flow Table with:", dailyReserveFlowLog); // Debug log
            // Populate Reserve Flow Table (Daily)
            dailyReserveFlowLog.forEach(data => {
                let totalOwedLiabilityClass = 'text-red-600'; // Default to red for liability
                
                // Display actual end-of-day reserve and liability for all days
                const displayedTotalReserve = formatCurrency(data.totalReserveEndOfDay, true);
                const displayedTotalOwedLiability = formatCurrency(Math.abs(data.totalOwedLiabilityEndOfDay), true); // Display absolute value
                
                // Net Reserve Coverage is the direct subtraction of the *actual* end-of-day balances
                const netReserveCoverageForDisplay = data.totalReserveEndOfDay - data.totalOwedLiabilityEndOfDay; // Actual subtraction
                const displayedNetReserveCoverage = formatCurrency(netReserveCoverageForDisplay, true);
                
                const displayedStatus = netReserveCoverageForDisplay >= 0 ? 'POSITIVE' : 'NEGATIVE';
                const netReserveCoverageClass = netReserveCoverageForDisplay >= 0 ? 'text-green-600' : 'text-red-600';
                const statusClass = netReserveCoverageForDisplay >= 0 ? 'text-green-600' : 'text-red-600';

                const row = `
                    <tr>
                        <td class="px-6 py-4 whitespace-nowrap">${data.day}</td>
                        <td class="px-6 py-4 whitespace-nowrap">${data.date.toLocaleDateString('en-JM', { month: 'short', day: 'numeric', year: 'numeric' })}</td>
                        <td class="px-6 py-4 whitespace-nowrap">${formatCurrency(data.reserveStart, true)}</td>
                        <td class="px-6 py-4 whitespace-nowrap">${formatCurrency(data.addReserve, true)}</td>
                        <td class="px-6 py-4 whitespace-nowrap">${formatCurrency(data.payCashback, true)}</td>
                        <td class="px-6 py-4 whitespace-nowrap">${displayedTotalReserve}</td>
                        <td class="px-6 py-4 whitespace-nowrap ${totalOwedLiabilityClass}">${displayedTotalOwedLiability}</td>
                        <td class="px-6 py-4 whitespace-nowrap ${netReserveCoverageClass}">${displayedNetReserveCoverage}</td>
                        <td class="px-6 py-4 whitespace-nowrap">
                            <span class="${statusClass}">
                                ${displayedStatus}
                            </span>
                        </td>
                    </tr>
                `;
                rfReserveFlowTableBody.insertAdjacentHTML('beforeend', row);
            });
        };

        // Event Listeners for Reserve Flow Calculator
        // No specific input for reserve flow needed as it's now driven by main simulation inputs

        // Initial setup for the new section
        document.addEventListener('DOMContentLoaded', () => {
            const today = new Date();
            today.setHours(0, 0, 0, 0); // Normalize to local midnight
            const year = today.getFullYear();
            const month = (today.getMonth() + 1).toString().padStart(2, '0');
            const day = today.getDate().toString().padStart(2, '0');
            simulationStartDateInput.value = `${year}-${month}-${day}`;

            updateInitialTradingFundDefault();
            initializeMainSimulationInputs(); // Initialize main simulation sales inputs first
            runSimulation();
            initializeReserveFlowInputs(); // Initialize reserve flow inputs
            runReserveFlowSimulation(); // Run the new simulation on load
        });

    </script>
</body>
</html>
